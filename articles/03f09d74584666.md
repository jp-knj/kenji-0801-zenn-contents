---
title: "便利になるために払い続けるコストについて"
emoji: "💬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
## はじめに
より効率的に開発を進める方法を探し続けていて、抽象化されたモノを利用しています。一方で、ライブラリやフレームワークの抽象化が開発者の知識を制限すると、その経験は否定的なものになりかねません。
この記事では、抽象化によって得られる利益と、それによって失われるものについて考えてみます。

## Web の進化の痕跡
文字情報を表示する単純なプラットフォームから、高機能なアプリケーションを動作させるために成長や変化をし続けてきました。この急速な変化は、過去の技術やアイディアの痕跡を残しています。

Web の起源は、情報を公開・共有するためのものだと記憶しています。
最初の Web ブラウザと Web サーバーは、CERN（ヨーロッパ原子核研究機構）のティム・バーナーズ＝リーによって 1989 年に考案されました。
目的は、科学者が研究成果や文書を共有や参照しやすくするためです。

初期の Web 技術である HTML（HyperText Markup Language）は、文書を構造化して表示するためのものです。HTML は、ヘッダーや段落、リストなどの基本的な文書構造要素と、他の文書へのハイパーテキストリンクを作成するための機能のみを提供していました。
しかし、時代とともに、Web は単なる文書共有のプラットフォームから、対話的なアプリケーションやサービスをホストするプラットフォームへと進化してきました。Web ページのデザインやインタラクティビティが飛躍的に向上しました。

#### 進化の痕跡
この急速な変化の中で、Web プラットフォームは旧来の技術や手法を取り込みつつ新しいものを導入してきました。その結果、古い API や技術と新しいものが共存しています。 そのため、Web プラットフォームが「でこぼこ」だと表現されています。

Web プラットフォームの開発は、複数の設計思想やマニフェストに基づいて行われています。その中でも、「Extensible Web Manifesto」は、Web の成長と進化において重要な役割を果たしています。
Web の基盤として低レベルの技術を優先することを提案されています。より高レベルな抽象化の負担はエコシステムの外側、つまり開発者コミュニティやライブラリ、フレームワークの作者たちに委ねられているのです。

### 低レベル技術の優先
「Extensible Web Manifesto」の考え方は、基本的には、新しい Web 機能や API を開発する際、その根底にある低レベルの技術を先に公開することを推奨しています。これにより、コミュニティがこれらの低レベルの機能を使用して実験や試作を行い、最終的には高レベルの API や抽象化を生み出すことができます。

一方で、これらの新しい高レベルの API や抽象化がエコシステムで試され、テストされ、そして成功と判断された場合、それは公式の Web プラットフォームに組み込まれることになります。

その結果、Web API の抽象化レベルには非常に大きなばらつきが見られます。具体例として、WebAssembly は低レベルの Virtual Machine であり、強力で汎用的な機能を提供する一方で、高レベルの便利な機能は提供しません。対照的に、CSS は高レベルの宣言的スタイリング言語であり、複雑なデザインやアニメーションを簡単に実現できる一方、宣言的に指定できる範囲内の機能しか提供しません。

イメージしてみてください。目の前にさまざまなサイズと高さのブロックがあります。これらのブロックは、Web プラットフォーム上のさまざまな API を表しています。ブロックが高ければ高いほど、その API は高レベルの抽象化を持っています。逆に低いブロックは、より低レベルの詳細に焦点を当てた API です。

このような多様なブロックの組み合わせが、現在の Web プラットフォームを形成しています。多様な API が提供されており、それぞれ異なる抽象化のレベルを持っています。

しかし、この多様性は、Web 開発者にとってもチャレンジをもたらしています。彼らは基本となる HTML、JavaScript、CSS はもちろん、さまざまな新しい技術やツールも学ぶ必要があります。例えば、History API にある pushState の特性を理解したり、新しい機能である CSS Grid や async/await の魅力を学ぶことでしょう。
また、現代の Web 開発では、ツールのエコシステム（例：pnpm、Rollup、Vite など）にも精通している必要があります。これは、開発の効率や品質を向上させるためのステップとなります。

### 学びと修正
多くのプロセスをよりシンプルで迅速にするための抽象化を設計しています。これは良いことだと思いますが、問題は「何を」ではなく「どのように」にあると感じます。

問題を解決するための知識（具体的には Web プラットフォームの知識）があるとき、抽象化がそれを妨げるときがあるでしょう。それにフラストレーションを感じます。

Web プラットフォームの形状が均一でないことは、一見すると開発者にとっての大きな障壁のように思えるかもしれません。しかし、実際には、多くの開発者はこのプラットフォームを既に熟知しており、その特性を上手く利用しています。

もし開発者が、自らが既に身につけているスキルや知識をサイドに置いて、新たな抽象化ツールやフレームワークを使わざるを得ない状況になると、それは彼らにとって必ずしもポジティブな経験とは言えないでしょう。

## 必要な脱出口 
### 抽象化の問題点 
抽象化が不十分または過剰であると、抽象化を貫通して内部で作業することが必要になる時があります。ときには、抽象化を使用しないことがあるでしょう。
しかし、フレームワークがアーキテクチャの中心に位置するため、抽象化から外れるのは難しいことがあります。フレームワークは、特定のフレームワーク向けに書かれており、それなしでは実行できません。これに対処するために、フレームワークは、開発者がより低レベルにある primitive にアクセスできるように、抽象化に意図的な穴、小さな脱出口を提供していることがあります。

例として、React は、対応する DOM 要素を取得するための ref プロパティを持っています。

特に大規模な場合、フレームワークを使用して開始しますが、ある時点でフレームワークを超えたり、長期間停滞したりすると、切り替えたくなることがあります。フレームワークはコードの形を変えるため、移行が難しいことがあります。ライブラリとの接触面は通常非常に小さく、1 つのライブラリから別のライブラリへの切り替えは、影響範囲が小さいタスクとなります。

脱出口はどんなライブラリやフレームワークにも絶対に必要になると考えています。すべてのユースケースを予測することは可能でしょうか。脱出口を提供することで、開発者は制限を回避して作業を続けることができます。エスケープハッチの欠点は、特にフレームワークにおいて、開発者がプラットフォームまで全体を落とすことが多いことです。これは、開発者にとって課題となることがあり、以前フレームワークが行っていた作業を再度行う必要があります。フレームワークとプラットフォームの間のギャップが大きいほど、開発者にとっての作業は増えます。

エスケープハッチは非常に重要であり、プラットフォームとフレームワークの間のギャップを手動で埋めることになり、開発者に負担をかけることがよくあります。最終的に、エスケープハッチの提供は開発者を制限しないために必要ですが、使用するためのコストがかかることもあるため、理想的ではありません。
フレームワークやライブラリの通常の動作や制約から逸脱することは、その後のメンテナンスやアップデートに影響を与える可能性があります。

開発者はフレームワークの提供する構造に従ってコードを書きます。
そのため、あるフレームワークから別のフレームワークへの移行は大変です。なぜなら、フレームワークはアプリケーションの基本的な構造や設計を決定付けるため、移行する際に多くの部分を書き換える必要があるからです。

## パターンの再利用
#### 抽象化の課題
抽象化での課題として、既存の Web プラットフォームのパターンを再利用しない傾向があります。
開発者が新しい方法を学ぶとき、”イディオム"（ある特定のコミュニティや技術の中での一般的な方法や慣習）や"純粋さ"（例えば、一貫性やシンプルさ）のためだと、不満を感じるように思えます。

### 抽象化と開発者の自由度
**開発者の選択の自由**
抽象化を行う際の主な目的の 1 つは、開発者の作業を簡単にすることです。しかし、あまりにも制約が多い抽象化は、開発者が柔軟に対応するのを難しくします。逆に、開発者に複数の選択肢を提供することで、彼らは既存のスキルや知識を活用して最適な方法で問題に取り組むことができます。

**抽象化の柔軟性**
抽象化がプラットフォームの既存のパターンに従っている場合、開発者はその抽象化を容易に理解しやすくなります。なぜなら、彼らは既にそのパターンや概念に慣れ親しんでいるからです。さらに、問題が発生した場合、StackOverflow のようなリソースで答えを見つけることができます。このような既存のリソースは、開発者が迅速に問題を解決する手助けをしてくれます。

**密閉された抽象化の問題点**
一方で、抽象化が完全に新しいパターンや概念を導入していて、プラットフォームの基本的な部分が隠蔽されている場合、それは開発者にとって難解になることがあります。特に、その抽象化に関する情報や資料が少ない場合、開発者は問題の解決方法を探すのが難しくなります。このような状況では、新しいブログ記事やチュートリアル、ドキュメントなどの情報源がウェブ上に多数存在する必要があります。それによって開発者が新しい抽象化を理解し、問題を解決するのに役立つ情報を得ることができます。

抽象化の設計は、開発者の既存の知識とスキルを最大限に活用できるようにすることが重要です。
そして、新しいパターンや概念を導入する場合は、それをサポートする十分な情報やリソースを提供することが必要です。

**背景の詳細**
- 抽象化とは、プログラミングの複雑さを簡略化し、一般的なコンセプトや機能を提供することを指します。
- 例：React や Vue.js は、DOM 操作の抽象化として機能します。開発者は DOM を直接触ることなく、より高水準の API でアプリケーションを構築できます。

**問題点の具体例**
- 抽象化は、開発者がその下にあるプラットフォームの具体的な実装詳細を知らなくても作業できるようにします。しかし、特定のニーズやパフォーマンスの最適化が必要な場合、この抽象化が障害となることがあります。
- 例：React Native でアプリを開発している場合、iOS と Android の具体的なプラットフォームの違いを気にしなくても良いです。しかし、特定のプラットフォーム固有の機能を使用する場合、React Native の抽象化の範囲を超えてネイティブコードにアクセスする必要があります。

**階層的アーキテクチャの具体例**
- 考え方：複数の抽象化レイヤーを持つシステムを想像してください。最下層はベアメタルなハードウェアや OS、次の層は基本的なライブラリやフレームワーク、さらに上の層は高度なユーティリティやツールがあるとします。
- 例：ゲーム開発を考えると、最下層がハードウェア、次の層がゲームエンジン（例：Unity）、さらに上の層が特定のゲームのロジックやキャラクターの動作となります。

**開発者の自由度の具体例**
- ゲーム開発の例を継続すると、ゲームエンジン（Unity など）の上で開発を進めている間は、ハードウェアの詳細や低レベルの API を気にする必要はありません。しかし、特定のハードウェア機能（例：特定の GPU 機能）を利用したい場合、エンジンの抽象化の範囲を超えて、より低いレイヤーにアクセスする自由が必要になります。

**下層の目的の具体例**
- 最下層では、ハードウェアや OS の提供する API や機能を最大限に活用し、それを効果的に利用するための基盤を提供します。
- 例：OpenGL や DirectX は、具体的な GPU の機能を抽象化し、開発者にグラフィックスプログラミングのための API を提供します。

**透明性と階層**
- 最上層が最も高いレベルの抽象化を提供する一方で、中間層が透過的にプラットフォームの具体的な詳細を露出させることで、開発者は必要に応じて適切なレイヤーを選択して作業できます。

開発者のメンタルモデルを中心に置くことは非常に重要です。それによって、どのような背景や経験を持つ開発者にとってもアクセスしやすく、理解しやすい抽象化を提供できます。

**メンタルモデルの一貫性**
開発者が既に持っている知識や経験を尊重し、その上で新しい概念や技術を導入することで、学習のカーブを緩和できます。

**認知的摩擦の最小化**
既存の概念やパターンを再利用することで、新しい技術やツールに慣れるプロセスをスムーズにできます。

**エスケープハッチの提供**
抽象化の制約に合わない特定のケースや要件に対応するための方法を提供することで、開発者の柔軟性と自由度を保護します。

**層状の抽象化**
それぞれのレベルでの抽象化を提供することで、開発者が自分のニーズや好みに合わせて最も適切なレベルを選択できます。

結局のところ、開発者のニーズや背景を理解し、それに合わせた抽象化を提供することで、技術の採用や成功の確率を高めることができます。これは、技術だけでなく、コミュニティや教育の側面からも、より多くの人々にとってアクセスしやすく、使いやすいものを作るための鍵となります。