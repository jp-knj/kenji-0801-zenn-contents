---
title: "フロントエンドが好きなので、Web フロントエンド良くしていきたいけど、辛いですの話"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
## はじめに
ユーザと Web サービスを UI で繋ぎ、最適な体験を提供することが、フロントエンドの役割です。
そのため、Web フロントエンド設計は厳格なルール、決まり事は存在しない場合が多く、チームの規模や開発スタイルによって、設計のルールは変わってくると思います。
システムの性質・仕様や要件とチームメンバーのスキル、デザイナーとの関係、開発フローから、少しづつ最適なものを選んでいくのが基本になるのではないでしょうか。

この記事は、私が Web フロントエンドの設計を行う上で、重要に思っていることを要約したものになります。
設計の1つの材料として、参考にしていただけると嬉しく思います。

## 想定読者

## コンポーネント設計の重要なポイント
- Figma 上からコンポーネント設計を行う
  - PdM,デザイナーとのコミュニケーション
  - 振舞駆動開発(behavior driven development)
- 単一責任の原則
  - 構造と見た目
  - UI とロジック
- 宣言型プログラミング
  - 状態管理
  - aria-* 属性
  - API、HTTP エラーハンドリング

### デザインツールからコンポーネント設計を行う
PdM,デザイナーと認識合わせを行いながら、コンポーネントの設計を「一緒に」進めて行くことになります。
デザイナーは構造について、開発者は機能性について、PdM はユーザにとってどれだけ有効であるかを探っていきます。
そして、認知パターンを明文化するのはチームでフロントエンドを改善する上で重要です。
デザインの構成要素（カラーパレット、タイポグラフィ）だけではなく、使用方法も確立していかなければなりません。
抑えておきたいポイントは以下の通りです。
- コンポーネントの名称
- 目的
- 例（UIの外観、実装コード）
- バリエーション(サイズ、色、状態)

信頼できる単一情報源としてのパターンライブラリを構築するのも、Web サービスを UI で繋ぐために重要なことです。

### 単一責任の原則

#### 構造と見た目

#### UI とロジック
UI とロジックは必ずしも「同じ」にする必要はありませんし、「別」にする必要もありません。
- 意味のある単位で UI と Logic を分割する
```tsx
import TabSwitcher, { Tab, TabPanel } from "./TabSwitcher";

function App() {
    return (
        <div className="App">
            <h1>TabSwitcher with Compound Components</h1>
            <TabSwitcher>
                <Tab id="a">
                    <button>a</button>
                </Tab>
                <Tab id="b">
                    <button>b</button>
                </Tab>

                <TabPanel whenActive="a">
                    <div>a panel</div>
                </TabPanel>

                <TabPanel whenActive="b">
                    <div>b panel</div>
                </TabPanel>
            </TabSwitcher>
        </div>
    );
}
```

複合コンポーネント/ Compound Component
### 宣言型プログラミング

#### 状態管理

前述したロジックの分類（UIロジックと業務ロジック）によって変わるかと思います。 コンポーネント単体で見るときれいに切り分けられている記事も見かけます。

しかしその1部品をルール化してプロジェクト全体に適応しようとすると、プロジェクトの規模や業務ロジックの複雑さも起因してどうしてもルールを守るのが苦しい場面に遭遇します。そして苦しいながらもルールを守るために、意味もなく複雑度の高いコンポーネントが生み出されます。

上手くUIとロジックの関係性をルール化するためにはロジックの分類を考慮する必要があります。

私の考えでは以下の使い分けが望ましいです。
UIとUIロジックは密結合
UIと業務ロジックは疎結合
UIロジックと業務ロジックは疎結合
個人的には、データの流れは一方向にして、保守性に優れた状態管理を実現できるためです。データの動きが見えづらいため、依存度の高さからデバッグやリファクタリングが難しいという問題が発生するでしょう。




## 想定読者

## コンポーネント設計の基本
- 単一責任の原則
- HTML の属性で宣言的にスタイリングする
  - ComponentProps 
  - コンポーネント内の要素についている [aria-*] の属性を適宜更新することによって、各要素の状態についてユーザーエージェントに情報を提供している。 
  - aria-selected による選択中であるかどうかのフラグ 
  - aria-controls による何の要素をコントロールしているかの識別子 
  - aria-hidden による表示中であるかどうかのフラグ 
  - .is-active や .is-hidden といったスタイル操作用の class と同様のタイミングで操作すべき「状態」を示す属性が多い。.is-* と併用するか、属性セレクタによるスタイル指定に抵抗がなければ [aria-*] だけで運用してもよいだろう。

### コンポーネントの分割

styled-components や emotion では Props に応じて中のスタイルを変えることができますが、変更の都度計算を行うためパフォーマンスに悪影響があります。そのため、HTML の属性やアクセシビリティ系のプロパティを変更して、スタイル側ではそれを参照するようにすると無駄なパフォーマンスコストが発生しなくなります。 styleプロパティを使うのもいいですが、useMemoを使わないと参照が毎回変わる、詳細度が高くなる、座標のような超動的なものと一緒になってしまう、等の理由からこちらのやり方を推奨します。
