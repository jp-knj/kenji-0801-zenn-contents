---
title: "React と localStorage で永続的な状態を保存する方法"
emoji: "💨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['react','typescript','localstorage']
published: false
---
## はじめに
useStateはReactの基本的なフックの一つである。しかし、useStateではステートを永続的に保持することはできない。ユーザーがページをリフレッシュすると、そのステートは消えてしまう。では、Reactでデータや状態を永続的に保持するにはどうすればいいのか。データを永続化するカスタムフックを書けばいい。

## 想定読者
- React, localStorage の基礎知識を保有している方 
-  

## 要約
- 実際のコードはこちら 

```typescript
import { useCallback, useState } from "react";

type Props<T> = {
	key: string;
	initialValue: T;
}

export const usePersistStore = ({ key, initialValue }: Props<T>): readonly [T, (v: T) => void] => {
	const getFromStorage = <T>(key: string, defaultValue?: T) => {
		try {
			const val = JSON.parse(localStorage.getItem(key) + "");
			if (val !== null) {
				return val;
			}
            return localStorage.setItem(key, JSON.stringify(defaultValue));
		} catch {
			return defaultValue;
		}
	};

	const [state, setState] = useState<T>(getFromStorage<T>(key, initialValue));

	const setValue = useCallback(
		(value: T) => {
			localStorage.setItem(key, JSON.stringify(value));
			setState(value);
		},
		[key]
	);

	return [state, setValue] as const;
};
```

## 何をやっているのでしょうか
OK、上のコードは混乱しているように見えるかもしれません。私は失敗したかもしれませんし、この特定のタスクのための理想的なソリューションかもしれません。判断するのはあなたです。

カスタムフックは状態をlocalStorageに保存し、必要なときにそれを返す。基本的にはこれだけです。

理解を深めるために順を追って書き換えていきましょう。

### 
localStorageにデータを保存するために、名前をつけなければならない。また、useStateと同じように、カスタムフックに初期値を与えたい場合もある。useStateのときと同じように、保存するデータの型も知っておきたい。これを実現するには、ジェネリックを使えばいい。

```typescript
type Props<T> = {
	key: string;
	initialValue: T;
}

export const usePersistStore = ({ key, initialValue }: Props<T>) => {
	const setValue = (value: T) => {};
};
```
### useState をしようしてみる
```typescript
import { useState } from "react";

type Props<T> = {
	key: string;
	initialValue: T;
}

export const usePersistStore = ({ key, initialValue }: Props<T>) => {
	const setValue = (value: T) => {};
    const [state, setState] = useState<T>(initialValue);};
}
```
セットロジックに入ります。ご想像の通り、データはlocalStorageに保存します。しかし、useStateにもデータを保存しておきたい。こうすることで、データを返すためにlocalStorageからデータを読み込む必要がなくなる。
```typescript
const setValue = (value: T) => {
    localStorage.setItem(name, JSON.stringify(value));
    setState(value);
};
```
とても簡単でしょう？しかし、これをuseCallbackの中でラップしないと、無限レンダリングループの問題が発生する。ReactはsetValue関数が変更されるかどうかを知らない。しかし、私たちは知っている。useEffectの内部でこの関数を使用する場合、依存関係の配列への追加を省略できるかもしれませんが、eslintは私たちを悩ますでしょう。
https://beta.reactjs.org/reference/react/useCallback
https://github.com/facebook/react/issues/14920
これをuseCallbackフックの中でラップして、名前を変更しないことがわかっている場合でも、名前の依存性を渡してみよう。
```typescript
const setValue = useCallback(
	(value: T) => {
		localStorage.setItem(key, JSON.stringify(value));
		setState(value);
	},
	[key]
);
```

## 
```typescript
const getFromStorage = () => {
    try {
        const val = JSON.parse(localStorage.getItem(key) + "");
        if (val !== null) {
            return val;
        }
        return localStorage.setItem(key, JSON.stringify(initialValue));
    } catch {
        return initialValue;
    }
};
```
基本的には、localStorageからデータを取得しようとしています。データが存在しない場合は、localStorageに保存する。このコードは、データが解析できない場合に備えて、try-catchブロックの中でラップされています。もしそうなら、コードはinitialValueを返します。

## コードを完成させましょう

getFromStorage関数をuseStateの上に配置する。getFromStorage()関数の呼び出しをuseStateに渡すには、以下のようにします。

では、ReactがuseStateで行っているように、setとgetの関数を返してみましょう。
```typescript
return [state, setValue] as const;
```

```typescript
import { useCallback, useState } from "react";

type Props<T> = {
	key: string;
	initialValue: T;
}

export const usePersistStore = ({ key, initialValue }: Props<T>): readonly [T, (v: T) => void] => {
	const getFromStorage = <T>(key: string, defaultValue?: T) => {
		try {
			const val = JSON.parse(localStorage.getItem(key) + "");
			if (val !== null) {
				return val;
			}
            return localStorage.setItem(key, JSON.stringify(defaultValue));
		} catch {
			return defaultValue;
		}
	};

	const [state, setState] = useState<T>(getFromStorage<T>(key, initialValue));

	const setValue = useCallback(
		(value: T) => {
			localStorage.setItem(key, JSON.stringify(value));
			setState(value);
		},
		[key]
	);

	return [state, setValue] as const;
};
```

You can verify it working by checking your developer console. You might also want to delete the entry in your localStorage.

## 最後に
"パッケージで処理すればいいのでは？"と。もちろん、できます。しかし、私はかなり基本的な問題を解決する方法のアイデアを提供したかったのです。私は、自分が使っている解決策を理解する方が好きなのです。

「コンポーネントの内部でローカルストレージにアクセスしたり、ローカルストレージから取得したりするのはどうでしょうか?それはうまくいくはずですが、私はよりエレガントな解決策を取りたかったのです。