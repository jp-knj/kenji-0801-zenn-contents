---
title: "Import On Interaction"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['react', 'javascript', 'Webパフォーマンス']
published: false
---

# はじめに
ユーザに必要な時に必要分だけファイルを読み込む

今。読み込まれているページには、**今はまだ必要でない**コンポーネントやリソースのコードやデータが読み込まれていることがあります。

具体的に 、ページの一部をクリックしたりスクロールしたりしない限り、ユーザーが目にすることのないユーザーインターフェースの一部などです。

これは、あなたがオーサリングした多くの種類のファーストパーティコードに適用できますが、`Video Player`や`Chat Widget`などのサードパーティウィジェットにも適用され、通常、ボタンをクリックしてメインインターフェイスを表示する必要があります。

これらのファイルを読み込みすると、コストがかかる場合はメインスレッドをブロックし、 ユーザーがページの重要な部分とやり取りできるまでの時間を短縮することができます。

これは、`First Input Delay`、`Total Blocking Time`、`Time to Interactiveなどのインタラクション・レディネス・メトリクスに影響を与える可能性があります。

**次のような、より適切なタイミングで読み込むことができます。**

ユーザーがそのコンポーネントをクリックしたとき、コンポーネントをスクロールして表示する
または、ブラウザがアイドル状態[^1]になるまでそのコンポーネントのロードを延期する。
[^1] 使用可能な状態なのに使用されていない、何の処理も行っていない、すぐ使用できるよう待機している、といった状態のこと
ファイルを読み込む方法を列挙させていただきます

- `Eager` - リソースをすぐに読み込みをする（スクリプトの通常の方法）。
- `Lazy (ルートベース)`- ユーザーがルートまたはコンポーネントに移動したときにロードされます。
- `Lazy (On interaction)`- ユーザーが UI をクリックしたときに読み込みはじめる (例: チャットの表示)。
- `Lazy (In viewport)` - ユーザーがコンポーネントに向かってスクロールしたときに読み込みはじめる。
- `Prefetch`- 必要になる前にロードし、重要なリソースがロードされた後にロードする。
- `Preload` - 切望して、より緊急性の高いもの


※ ファーストパーティーコードのインポートオンインタラクションは、インタラクションの前にリソースを`Prefetch`できない場合にのみ実行すべきです。

しかし、このパターンはサードパーティのコードに非常に適しており、一般に、重要でない場合は後の時点に延期することになります。

これはさまざまな方法で実現できます（インタラクションが発生するまで、ブラウザがアイドル状態になるまで、またはその他のヒューリスティックを使用して延期します）。
インタラクション時に機能コードを遅延してインポートすることは、この投稿で取り上げる多くの文脈で使用されるパターンです。Google Docsでは、ユーザーとのインタラクションがあるまでロードを延期することで、共有機能のための500KBのスクリプトのロードを節約しています。

インポート・オン・インタラクションがうまく機能するもう一つの場所は、サードパーティーのウィジェットを読み込むことです。

## サードパーティーのUIをファサードで読み込む "フェイク"
サードパーティのスクリプトをインポートする場合、レンダリング内容やコードの読み込みタイミングをあまり制御できないことがあります。
ロードオンインタラクションを実装するための1つの選択肢は、ファサードを使用するという単純明快なものです。
ファサードは、より高価なコンポーネントのためのシンプルな「プレビュー」または「プレースホルダー」であり、画像やスクリーンショットなど、基本的な体験をシミュレートすることができます。
Lighthouseのチームでは、このアイデアを専門用語として使っています。

ユーザーが「プレビュー」（ファサード）をクリックすると、そのリソースのコードが読み込まれます。
これにより、ユーザーは、その機能を使用する予定がない場合、その機能に必要なエクスペリエンス・コストを支払う必要がなくなるのです。
同様に、ファサードは、ホバー時に必要なリソースに事前に接続することができます。

※ サードパーティーのリソースは、サイト全体の読み込みを十分に考慮せずにページに追加されることがよくあります。
同期的にロードされるサードパーティーのスクリプトは、ブラウザのパーサーをブロックし、読み込みを遅らせる可能性があります。
可能であれば、3Pスクリプトは非同期/遅延（または他のアプローチ）でロードし、1Pスクリプトがネットワーク帯域を奪われないようにする必要があります。
重要なものでなければ、import-on-interactionなどのパターンを使って遅延ロードに移行させるのがよいでしょう。

#### 動画プレーヤーの埋め込み
「ファサード」の良い例として、Paul Irish氏によるYouTube Lite Embedがあります。
これは、YouTube Video ID を受け取り、最小限のサムネイルと再生ボタンを表示するカスタム要素を提供します。
この要素をクリックすると、YouTube の埋め込みコードが動的に読み込まれます。
つまり、再生をクリックしないユーザーは、埋め込みコードの取得と処理にかかるコストを支払う必要がありません。

### 認証について
アプリは、クライアントサイドのJavaScript SDKを使用して、あるサービスとの認証をサポートする必要がある場合があります。これらのSDKは時に大きく、JSの実行コストも高いため、ユーザーがログインしないのであれば、前もって読み込まないほうがよいでしょう。
その代わりに、ユーザーが "Login" ボタンをクリックしたときに認証ライブラリを動的にインポートすることで、初期ロード中にメインスレッドをより自由に保つことができます。

### チャットウィジェット
キャリバーのアプリは、Intercomベースのライブチャットのパフォーマンスを、同様のファサードアプローチを使用することで30%向上させました。彼らは、クリックすると Intercom バンドルをロードする、CSS と HTML だけで「偽の」高速ロードライブチャットボタンを実装しました。

Postmark は、ヘルプチャットウィジェットが、顧客によって時々しか使用されないにもかかわらず、常に熱心にロードされていることを指摘しました。ウィジェットには314KBのスクリプトがあり、ホームページ全体よりも多くのスクリプトが読み込まれていました。ユーザーエクスペリエンスを向上させるために、HTMLとCSSを使用してウィジェットを偽のレプリカに置き換え、クリック時に本物をロードするようにしました。この変更により、Time to Interactiveは7.7秒から3.7秒に短縮されました。

### どうやって動的にファイルを読み込むのか？
JavaScriptでは、`dynamic import`はファイルの`lazy loading`可能にし、`Promise`を返すので、正しく適用すれば非常に強力です。
下記はボタンの`EventListener`で `dynamic import` を使って `lodash.sortby`ファイルを読み込みます。

```javascript
const btn = document.querySelector('button');

btn.addEventListener('click', e => {
  e.preventDefault();
  import('lodash.sortby')
    .then(module => module.default)
    .then(sortInput()) // use the imported dependency
    .catch(err => { console.log(err) });
});
```

`dynamic import` の前に、あるいはそれがうまく機能しない使用例では、`Promise` の `scriptLoader()` を使ってページにスクリプトを動的に注入することも可能でした。

```javascript
const loginBtn = document.querySelector('#login');

loginBtn.addEventListener('click', () => {
  const loader = new scriptLoader();
  loader.load([
      '//apis.google.com/js/client:platform.js?onload=showLoginScreen'
  ]).then(({length}) => {
      console.log(`${length} scripts loaded!`);
  });
});
```

#### Reactの場合
例えば、`<MessageList>`、`<MessageInput>`、`<EmojiPicker>コンポーネント` (emoji-mart を使用、98KB minified and gzipped) を持つチャットアプリケーションがあるとしましょう。
最初のページロード時に、これらのコンポーネントをすべて`Eager`な読み込むのが一般的でしょう。

```javascript
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import EmojiPicker from './EmojiPicker';

const Channel = () => {
  ...
  return (
    <div>
      <MessageList />
      <MessageInput />
      {emojiPickerOpen && <EmojiPicker />}
    </div>
  );
};
```

この作業の読み込むを分割するのは、`code splitting` を使えば比較的簡単です。
`React.lazy()`を使うと、`dynamic import`を使ってReactアプリケーションをコンポーネントレベルで簡単にコード分割(code splitting)することができます。
`React.lazy()`は、アプリケーション内のコンポーネントをJavaScriptの別々のchunkに分離する組み込みの方法を提供します。
`Suspenseコンポーネント`と組み合わせることで、状態の読み込みを行うことができます。

```javascript
import React, { lazy, Suspense } from 'react';
import MessageList from './MessageList';
import MessageInput from './MessageInput';

const EmojiPicker = lazy(
    () => import('./EmojiPicker')
);

const Channel = () => {
...
    return (
        <div>
            <MessageList />
            <MessageInput />
            {emojiPickerOpen && (
                <Suspense fallback={<div>Loading...</div>}>
                    <EmojiPicker />
                </Suspense>
            )}
        </div>
    );
};
```

このアイデアを拡張して、アプリケーションが最初にロードされたときにEagerlyではなく、`<MessageInput>`で絵文字アイコンがクリックされたときにのみ、`Emoji Pickerコンポーネント`のコードを読み込むことができる。

```javascript
import React, { useState, createElement } from 'react';
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import ErrorBoundary from './ErrorBoundary';

const Channel = () => {
  const [emojiPickerEl, setEmojiPickerEl] = useState(null);

  const openEmojiPicker = () => {
    import(/* webpackChunkName: "emoji-picker" */ './EmojiPicker')
      .then(module => module.default)
      .then(emojiPicker => {
        setEmojiPickerEl(createElement(emojiPicker));
      });
  };

  const closeEmojiPickerHandler = () => {
    setEmojiPickerEl(null);
  };

  return (
    <ErrorBoundary>
      <div>
        <MessageList />
        <MessageInput onClick={openEmojiPicker} />
        {emojiPickerEl}
      </div>
    </ErrorBoundary>
  );
};
```

インタラクション(ユーザの操作)に応じてファイルを読み込むことは、GoogleがFlightsやPhotosのような大規模なアプリケーションで [Progressive Loading](https://developer.mozilla.org/ja/docs/Web/Progressive_web_apps/Loading) [^2]を処理する方法の重要な部分でもあります。これを説明するために、以前 Shubhie Panicker 氏が紹介した例を見てみましょう。

インドのムンバイへの旅行を計画しているユーザーが、Google Hotels にアクセスして料金を確認するとします。
インタラクション(ユーザの操作)に必要なリソースはすべて事前に`Eargley`に読み込むことができますが、ユーザーが目的地を選択していない場合は、地図に必要な HTML/CSS/JS は不要になります。



Google HotelsがCSR(クライアントサイドレンダリング) を使用していると想像してください。HTML、JS、CSS、そしてデータの取得と、すべてのコードがダウンロードされ、前もって処理され、すべてが揃ってから描画が行われます。
しかし、これでは画面に何も表示されないまま、ユーザーを長時間待たせてしまうことになります。JavaScriptやCSSの大部分は不要かもしれません。



次に、この体験をSSR(サーバーサイドレンダリング)に移行した場合を想像してみましょう。

この場合、ユーザーは視覚的に完全なページをより早く得ることができます。

これは素晴らしいことですが、サーバーからデータが取得され、クライアントフレームワークが水分補給を完了するまで、インタラクティブにはなりません。


SSRは改善されますが、ユーザーは、ページが準備できたように見えても、何もタップできないページを生成します。
これは、ユーザーがイライラして何度も何度もクリックする傾向があるため、`lazy click`と呼ばれることもあります。

Google Hotel 検索の例に戻ると、UIを少し拡大してみると、ユーザーがまさに適切なホテルを見つけるために「more filters」をクリックすると、そのコンポーネントに必要なコードがダウンロードされることがわかります。

最初にダウンロードされるのはごくわずかなコードだけで、それ以降はユーザーの操作によって、どのコードがいつ読み込まれるか決まります。

このロードシナリオをもう少し詳しく見てみましょう。


インタラクションドリブンなレイトローディングには、いくつかの重要なポイントがあります。

1. まず、最初に最小限のコードをダウンロードし、ページが視覚的にすばやく完成するようにします。
2.次に、ユーザーがページとインタラクションを始めると、そのインタラクションを利用して、ロードする他のコードを決定します。たとえば、「more filters」コンポーネントのコードを読み込むなどです。
つまり、ページ上の多くの機能のコードは、ユーザーが使用する必要がないため、ブラウザに送信されることはないのです。



### 初期のクリックを失わないためには？

これらのGoogleチームによって使用されるフレームワークスタックでは、最初のHTMLのチャンクに小さなイベントライブラリ（JSAction）が含まれているため、早期にクリックを追跡することができます。

イベントは次の2つの目的で使用されます。

ユーザーとのインタラクションに基づくコンポーネント コードのダウンロードのトリガー
フレームワークのブートストラップが終了したら、ユーザーインタラクションを再生する。
その他、コンポーネントコードの読み込みなど、ヒューリスティックを利用することができます。

アイドルタイム後の一定期間
関連するUI/ボタン/Call to Actionにユーザーがマウスを乗せたとき
ブラウザのシグナル（例：ネットワーク速度、データセーバーモードなど）に基づく熱心さのスライディングスケールに基づく。



### データについてはどうですか？

ページのレンダリングに使用される初期データは、初期ページのSSR HTMLに含まれ、ストリーム配信されます。

遅れてロードされるデータは、どのコンポーネントと一緒にロードされるかがわかるので、ユーザーのインタラクションに基づいてダウンロードされます。

これで、CSSやJSと同じようにデータの取り込みが行われ、インポート・オン・インタラクションの図式が完成しました。
コンポーネントは、どのコードとデータが必要かを認識しているので、すべてのリソースがリクエスト以上の距離にあることはありません。



これは、ビルド時にコンポーネントとその依存関係のグラフを作成するように機能します。
ウェブアプリケーションは任意の時点でこのグラフを参照し、任意のコンポーネントに必要なリソース（コードとデータ）を迅速に取得することができます。
また、ルートではなく、コンポーネントに基づいてコードを分割することになります。

上記の例のウォークスルーは、Elevating the Web Platform with the JavaScript Community を参照してください。


#### トレードオフ

コストのかかる作業をユーザーとのインタラクションに近づけることで、ページの初期ロード時間を最適化することができますが、トレードオフがないわけではありません。

ユーザーがクリックした後、スクリプトを読み込むのに長い時間がかかるとしたら、どうなるでしょうか。

Google Hotelsの例では、小さな粒状のチャンクが、コードやデータの取得と実行のためにユーザーが長時間待つ可能性を最小限に抑えます。
他の例では、依存関係が大きいと、低速のネットワークではこの懸念が生じる可能性があります。

このような事態を減らす方法のひとつは、ページの重要なコンテンツがロードされた後に、これらのリソースをより適切に分割してロードするか、またはプリフェッチすることです。

この影響を測定して、あなたのアプリで実際にどの程度適用できるかを判断することをお勧めします。

ユーザーとのインタラクションの前に機能がないのはどうでしょうか？

ファサードのもうひとつのトレードオフは、ユーザーとのインタラクションの前の機能性の欠如です。

たとえば、埋め込みビデオプレーヤーは、メディアを自動再生することができません。このような機能が重要な場合、リソースの読み込みに別のアプローチを検討することもできます。

たとえば、サードパーティのiframeをユーザーがスクロールして表示する際に、インタラクションが発生するまで読み込みを延期するのではなく、遅延ロードするようにします。


#### インタラクティブなembedを静的なバリアントで置き換える
これまで、インポート・オン・インタラクション・パターンとプログレッシブ・ローディングについて説明してきましたが、エンベッドのユースケースについて、完全に静的にすることはどうでしょうか？

例えば、ソーシャルメディアの投稿が最初のビューポートに表示されるような場合、埋め込みから最終的にレンダリングされたコンテンツがすぐに必要になることがあります。

この場合、埋め込みに2〜3MBのJavaScriptを使用すると、独自の課題が発生する可能性があります。埋め込みコンテンツがすぐに必要なため、レイジーローディングやファサードが適用しにくくなる可能性があります。

パフォーマンスを最適化する場合、埋め込みコンテンツを、よりインタラクティブなバージョン（たとえば、オリジナルのソーシャルメディア投稿）にリンクする、類似した静的バージョンに完全に置き換えることが可能です。

ビルド時に、埋め込み用のデータを取り込み、静的なHTMLバージョンに変換することができます。

これは、@wongmjaneが彼らのブログでソーシャルメディアの埋め込みタイプのために活用したアプローチで、ページのロードパフォーマンスと、埋め込みコードがフォールバックテキストを強化するために経験した累積レイアウトシフトを削除し、レイアウトシフトの両方を向上させるものです。

静的な置き換えはパフォーマンスには良いのですが、多くの場合、カスタムで何かをする必要があるので、オプションを評価する際にはこのことを念頭に置いてください。

#### 結論

ファーストパーティのJavaScriptはしばしばウェブ上のモダンなページのインタラクションの準備に影響を与えますが、メインスレッドを忙しくさせるファーストまたはサードパーティのソースからの重要でないJSの後ろでネットワーク上でしばしば遅れることがあります。

一般に、ドキュメントヘッドでのサードパーティ製スクリプトの同期は避け、ファーストパーティ製JSの読み込みが完了した後にノンブロッキングのサードパーティ製スクリプトを読み込むようにします。インポート・オン・インタラクションのようなパターンは、クリティカルでないリソースのロードを、ユーザーがUIを必要とする可能性が高い時点まで延期する方法を提供します。