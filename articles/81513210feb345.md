---
title: "ローディングを最適に"
emoji: ""
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
# ローディングシーケンスを最適化する
ローディングシーケンスを最適化することで、アプリの操作性を向上させる方法について説明します。

Webページの読み込みが成功するたびに、重要なコンポーネントやリソースが適切なタイミングで利用可能になり, スムーズな読み込みをします。
パフォーマンスが良いと、一般に[Core Web Vital](https://web.dev/vitals/)の基準をクリアすることになります

パフォーマンスを測定するために使用される
- FCP : First Content Paint
  - 「最初にコンテンツを表示する」までにどれくらいの時間がかかったのかを表す。
- LCP : Largest Contentful Paint 
  - 「最も大きなコンテンツ(画像など)を表示する」までにどれくらいの時間がかかったのかを表す。
  - ページが最初にロードを開始してから 2.5秒以内にLCPが発生する必要があります。
- FID : First Input Delay

３つの測定基準は、読み込みの順序に大きく影響されます。

たとえば、ヒーロー画像のような重要なリソースがロードされないと、ページはそのLCPを持つことができません。
この記事では、リソースの読み込まれる順番とWeb vitalsの関係について説明します。

その目的は、より良いWeb vitalsを実現するために読み込み順序を最適化する方法について、明確な指針を示すことにあります。

理想的な読み込み順序を確立する前に、まず読み込み順序を正しく設定することがなぜ難しいかを理解しましょう。

## なぜ最適なロードを実現することが難しいのか？
最適ではないパフォーマンス・スコアになってしまった場合、複数の要点が挙がります。

### 最適でない順序付け
Web Vitalsの最適化には、
測定が何を表しているかを理解するだけでなく、
それらが発生する順序や、
各ファイルはどのように関連しているかを理解する必要があります。

FCP → LCP → FID
なので、FCPを達成するために必要なリソースは、LCPで必要なリソースよりも優先され、次にFIDで必要なリソースが優先されるべきです。

リソースは正しい順序で配列され、パイプライン化されていないことが多く、がメトリクスとリソース負荷の依存関係を認識していないためと思われます。
その結果、関連するリソースが、対応するメトリクスがトリガーされる適切なタイミングで利用できないことがある。

例を挙げます。

a) FCPが起動するまでに、LCPを起動するためのヒーロー画像が利用可能であるべきです。
b) LCP が起動する頃には、JavaScript が `loading`され、`parse`され、インタラクション（FID）のブロックを解除する準備ができている（すでに実行されている）べきである。

### ネットワーク/CPUの使用率

また、CPUやネットワークをフルに活用するために、リソースが適切にパイプライン化されていない。
その結果、プロセスがネットワークに接続しているときはCPUに「デッドタイム」が発生し、逆にネットワークに接続しているときはCPUに「デッドタイム」が発生します。

この好例が、同時または連続的にダウンロードされるスクリプトです。
同時ダウンロードでは帯域幅が分割されるため、すべてのスクリプトをダウンロードするための合計時間は、順次ダウンロードと同時ダウンロードの両方で同じになります。
スクリプトを同時ダウンロードする場合、ダウンロード中にCPUが十分に活用されません。
しかし、スクリプトを順次ダウンロードする場合、CPUは最初のスクリプトをダウンロードするとすぐに処理を開始できます。
この結果、CPUとネットワークの使用率が向上します。

### サードパーティライブラリ

サードパーティライブラリは、多くの場合、Webサイトに共通の機能や特徴を追加するために必要とされます。

3P製品は通常、消費者サイトの読み込みパフォーマンスを最適化し、サポートするインセンティブを持ちません。
JavaScriptの実行コストが高く、インタラクティビティを遅らせたり、他のhtml/css/jsファイルのダウンロードの邪魔になったりする可能性があります。

Webサイトのパフォーマンスへの影響よりも、機能で価値に重点を置く傾向があるかもしれません。
その結果、全体の読み込み順序を十分に考慮することなく、無造作に追加されることがあります。
このため、サードパーティライブラリの制御やスケジューリングが難しくなります。

### プラットフォームの癖

ブラウザによって、リクエストの優先順位付けやヒントの実装方法が異なる場合があります。
プラットフォームとその癖について深い知識があれば、最適化は容易になります。
特定のブラウザに特有の挙動があると、望ましい読み込み順序を一貫して実現することが難しくなります。

この例として、chromium (Google Chromeの元Webブラウザ)の preload バグが挙げられます。
Preload `<link rel=preload>` 命令は、主要なリソースをできるだけ早くダウンロードするよう、ブラウザに指示するために使用できます。
これは、そのリソースが現在のページで使用されることが確実な場合にのみ使用されるべきです。
Chromium のバグにより、<link rel=preload> で発行されたリクエストは、たとえ優先度が高いものであっても、常に preload スキャナで検出された他のリクエストより先に開始されるような動作が発生します。
このような問題は、最適化計画に支障をきたします。

### HTTP2 の優先順位付け

プロトコル自体には、リソースの順序や優先順位を調整するためのオプションは充実されていません。
たとえより優れた優先順位付けのプリミティブが利用可能になったとしても、HTTP2 の優先順位付けには、最適な順序付けを難しくする根本的な問題があります。
主に、サーバーや CDN が個々のリソースへのリクエストにどのような順番で優先順位をつけるかを予測することはできません。
CDN の中にはリクエストを再優先するものもあれば、部分的な優先順位付け、欠陥のある優先順位付け、あるいは優先順位付けを行わないものを実装しているものもあります。

### リソースレベルの最適化
効果的な順序付けを行うには、順序付けされるリソースが最適に提供され、素早く読み込まれる必要があります。
`

読み込みファイルを分割するために、以下のいずれかの手法を使用します。

Modern React の機能(Suspense / Concurrent mode / Data Fetching) 
`Dynamic import`による`lazy loading`
コードを分割する場合、フロントエンドエンジニアは、粒度とパフォーマンスのトレードオフのために、`chunk`のちょうどよい粒度を定める必要があります。

## より高い粒度が望ましい理由は

個々のルートとその後のユーザーインタラクションに必要なJSを最小化する。
共通の依存関係のキャッシュを可能にする。これにより、ライブラリに変更があった場合でも、バンドル全体を再取得する必要がなくなります。
同時に、コード分割の粒度を上げすぎると、小さなチャンクが多すぎて個々のチャンクの圧縮率が下がり、ブラウザのパフォーマンスに影響するため、好ましくないことがあります。

リソースの最適化には、未使用で不要なコードを排除することも必要です。
不要な JS や時代遅れの JS がモダンブラウザに同梱されていることがありますが、これはパフォーマンスに悪影響を及ぼします。
ES5に変換され、polyfillにバンドルされたJS は、モダンブラウザには不要です。
ライブラリやnpmパッケージは、ESモジュール形式で公開されていないことが多い。
ツリーシェイクや最適化を行うことが困難である。

お気づきかもしれませんが、これらの問題は、特定のリソースやプラットフォームに限定されるものではありません。
これらの問題を回避するためには、技術スタック全体を理解し、最適な指標を達成するためにどのように異なるリソースを合体させることができるかを理解することが必要です。
全体的な最適化戦略を定義する前に、個々のリソース要件がいかにして目的を達成できないかを見てみましょう。

#リソースの詳細 - 関係、制約、および優先順位 

前節では、FCPやLCPのような特定のイベントが発生するために、特定のリソースが必要であるという例をいくつか挙げました。
ここでは、そのような依存関係をすべて理解してから、それらを扱う方法について説明します。
以下は、理想的なシーケンスを定義する前に考慮する必要がある、推奨、制約、およびゲッチャのリソース別のリストです。

## クリティカルCSS - 必要最低限なCSS
`Critical CSS`とは、必要な最低限のCSSのことです。
他のCSSファイルからimportするのではなく、HTML内にインライン化するのが望ましいとされています。
例えば、ユーザーのファーストビューに必要なスタイルだけを `<style> タグ`を使ってインライン化すると、リソースサイズの肥大化を最小限に抑えながら、かつより良いパフォーマンスの改善ができます。
```html
<head>
  <style>
      body{background:#fff;color:#000;margin:0}.link{color:#1a0dab}.link{border-collapse:collapse}.list items{padding:0}.item{color:#000}....
  </style>
</head>
```
このようなCSSは、 ルートに必要なCSSのみを随時ダウンロードし、Critical CSSはすべてそれに応じて分割する必要がある。

インライン化が難しい場合は、Critical CSSはあらかじめロードしておき、ドキュメントと同じオリジンから提供する必要があります。
複数のドメインから、Critical CSSを提供したり、Google Fontsのよう外部のCriticalCSSを直接使用することは避けてください。

自分のサーバーをサードパーティーのCSSのプロキシとして機能させることもできます。

CSSの取得に遅延が生じたり、CSSの取得順序が正しくない場合、FCPやLCPに影響を与える可能性があります。
これを避けるため、インライン化されていないCSSは、ネットワーク上で1P JSやABTイメージよりも優先的に処理され、順序付けられるべきではないでしょうか。

### インラインCSSは多すぎてもよくない理由
`インラインCSS` が多すぎると、HTML が肥大化し、style を **parse**(構文解析) の時間が長くなる可能性があり、 FCP に損害を与える可能性があります。
そのため、何が必要最低限で、コードを分割することが重要です。インラインCSSはファイルのリクエスト数を減らすための手段の一つです

あとCSSをインライン化すると、ブラウザキャッシュは使えません。
しかし、ブラウザキャッシュはサーバーからの受け渡し時間を短縮するだけで、
1度目の読み込みはブラウザキャッシュは効果を発揮せず(ブラウザキャッシュはCSSファイルを読み込みますが取得しないため)。
2度目以降もファイル自体を読み込むのは変わらず、CSSのファイル数分だけ読み込みが入ります。

CSSについては現在のパフォーマンスからボトルネックを洗い出しつつ、最適化させるのが正しい高速化設定の使い方だと思います。

## フォント

[critical css](https://web.dev/extract-critical-css/)と同様に、重要なフォントのCSSもインライン化する必要があります。
インライン化が不可能な場合は、[preconnect](https://web.dev/uses-rel-preconnect/)を指定して script を読み込む必要があります。
Googleフォントや別ドメインのフォントなど、フォントの取得に時間がかかると、FCPに影響が出ることがあります。
preconnect は、これらのリソースへの接続を早めにセットアップするようにブラウザに指示します。

フォントのインライン化は、HTMLを著しく肥大化させ、他の重要なリソースのフェッチを開始するのを遅らせる可能性があります。
[フォント・フォールバック](https://css-tricks.com/css-basics-fallback-font-stacks-robust-web-typography/)は、FCPのブロックを解除し、テキストを利用可能にするために使用される場合があります。
しかし、フォントフォールバックを使用すると、フォントがジャンプするため、[CLS](https://web.dev/cls/)に影響を与える可能性があります。
また、実際のフォントが到着したときに、メインスレッドで大規模なスタイルおよびレイアウトタスクが発生する可能性があるため、FID にも影響を与える可能性があります。

## Above the Fold（ABT）画像

ページロード時にビューポート内にあるため、ユーザーに最初に表示される画像のことです。
ABT画像の特別なケースは、ページのヒーロー画像です。
ABT画像はすべて、サイズを調整する必要があります。
サイズ調整されていない画像は、完全にレンダリングされたときにレイアウトが変化するため、CLSの指標に影響を与えます。
ABT 画像のプレースホルダーは、サーバーによってレンダリングされるべきです。

遅延したヒーロー画像や空白のプレースホルダーは、LCPの遅延を招きます。
さらに、プレースホルダのサイズが実際のヒーロー画像の固有サイズと一致せず、画像が置き換えでオーバーレイされない場合、LCPは再トリガーされます。
理想的には、ABT画像によるFCPへの影響はないはずですが、実際には、画像がFCPを発生させることがあります。

## BTF（Below the Fold）画像

ページロード時にユーザーからすぐに見えない画像です。
そのため、レイジーローディングの理想的な候補となります。
これにより、ページ上で必要とされる1P JSや重要な3Pと競合することがありません。
もしBTF画像が1P JSや重要な3Pリソースよりも先にロードされると、FIDが遅延してしまいます。

## 1P JavaScript

1P JSは、アプリケーションのインタラクションレディネスに影響を与える。
画像と3P JSの背後にあるネットワークと、3P JSの背後にあるメインスレッドで、遅延する可能性があります。
そのため、ネットワーク上ではABTイメージの前にロードを開始し、メインスレッドでは3P JSの前に実行されるべきです。
1P JSは、サーバーサイドでレンダリングされるページでは、FCPとLCPをブロックしない。

## 3P JavaScript

3P sync script in HTML head は CSS & font parsing をブロックする可能性があり、その結果 FCP もブロックされる可能性があります。
また、head内の同期スクリプトは、HTMLボディのパースもブロックする。
メインスレッドでの3Pスクリプトの実行は、1Pスクリプトの実行を遅らせ、ハイドレーションとFIDを押し出す可能性があります。
そのため、3Pスクリプトのロードには、より良い制御が必要です。

これらの推奨事項や制約事項は、技術スタックやブラウザに関係なく、一般的に適用されます。
推奨事項であるものが、どのように制約になり得るかに注意してください。
例えば、フォントやCSSのインライン化は素晴らしいことですが、やり過ぎると肥大化の原因になります。
コツは、「Too little Too late」と「Too much Too soon」の間のバランスを見つけることです。

次の図は、さまざまなリソースを読み込む際のChromeの優先順位を理解するためのものです。
優先順位に関する情報とリソースの種類に関する議論を組み合わせることで、次のセクションで提案する読み込み順序をより理解することができます。

## 以下は、この表から得られる重要なポイントである。

1. CSSとFontsは最も高い優先度でロードされます。これは、重要なCSSとフォントの優先順位付けに役立つはずです。
2. script は、document内の位置と、非同期、遅延、ブロックのいずれであるかによって、優先順位が異なります。
3. 最初の画像 (またはドキュメントの初期の画像) の前に要求されたブロッキングスクリプトは、最初の画像が取得された後に要求されたブロッキングスクリプトよりも高い優先順位が与えられます。
非同期/遅延/injection のスクリプトは、ドキュメント内の位置に関係なく、最も低い優先順位となります。したがって、[async と defer](https://javascript.info/script-async-defer) に適切な属性を使用することで、さまざまなスクリプトに優先順位をつけることができます。
可視で viewport内 にある画像は、viewport内にない画像（Net: Lowest）よりも高い優先度（Net: Medium）を持ちます。
これにより、ABT画像をBTF画像よりも優先させることができます。

それでは、上記の詳細をすべてまとめて、最適な読み込み順序を定義する方法を見ていきましょう。

## 理想的なローディングシーケンスとは？
このような背景から、1Pと3Pの両方のリソースの読み込みを最適化するための読み込み順序を提案することができます。
提案する順序は、Next.jsのServer Side Rendering (SSR)を参考に最適化を図ります。

### 現状
これまでの経験から、最適化前のNext.jsのSSRアプリケーションで観測された典型的な読み込み順序は次のとおりです。

CSS: CSSはJSの前にロードされるが、インライン化されない。
JavaScript: 1P JSがプリロードされる
            3P JSは管理されず、ドキュメント内のどこでもレンダーブロッキングを起こす可能性があります。
font: フォントはインラインでもプリコネクトでもありません。フォントは外部スタイルシートを介して読み込まれるため、読み込みに時間がかかる フォントは表示ブロックになる場合とならない場合があります。
images: ヒーローの画像は優先されない
ABT画像、BTF画像ともに最適化されていない

以下は、あるパートナーサイトのこのようなシーケンスの一例です。
このロードシーケンスに関するポジティブな点とネガティブな点を注釈として含んでいます。

## 理想的なローディングシーケンスとは？
このような背景から、1Pと3Pの両方のリソースの読み込みを最適化するための読み込み順序を提案することができます。
提案する順序は、Next.jsのServer Side Rendering (SSR)を参考に最適化を図ります。

### 現状
これまでの経験から、最適化前のNext.jsのSSRアプリケーションで観測された典型的な読み込み順序は次のとおりです。

CSS CSSはJSの前にロードされるが、インライン化されない。
JavaScript 1P JSがプリロードされる
3P JSは管理されず、ドキュメント内のどこでもレンダーブロッキングを起こす可能性があります。
フォント フォントはインラインでもプリコネクトでもありません。
フォントは外部スタイルシートを介して読み込まれるため、読み込みに時間がかかる
フォントは表示ブロックになる場合とならない場合があります。
画像 ヒーローの画像は優先されない
ABT画像、BTF画像ともに最適化されていない

以下は、あるパートナーサイトのこのようなシーケンスの一例です。このロードシーケンスに関するポジティブな点とネガティブな点を注釈として含んでいます。

## 3Pを使用しない場合の提案シーケンス
以下は、先に述べた制約をすべて考慮したロードシーケンスである。
まず、3Pを使わないシーケンスに取り組みましょう。
次に、このシーケンスで3Pリソースをどのようにインターリーブすることができるかを見ていきます。
なお、ここではGoogle Fontsを1Pとみなしている。

メインブラウザのスレッドにおけるイベントのシーケンス ネットワーク上のリクエストのシーケンス。
- 1 HTMLを解析する
小さなインラインの1Pスクリプト。
1
- 2 小さなインライン1Pスクリプトの実行 インラインクリティカルCSS（外部の場合はプリロード） 2
インライン・クリティカル・フォント（外部の場合はプリコネクト） 3
- 3 FCP リソース（クリティカル CSS、フォント）のパース LCP イメージ（外部であればプリコネクト） 4
ファーストコンテントフルペイント（FCP）フォント（インラインfont-css（Preconnect）からトリガー） 5
- 4 LCPリソースのレンダリング（Hero画像、テキスト） ノンクリティカル（非同期）CSS 6
インタラクティビティのためのファーストパーティJS 7
- Above the fold画像（プリコネクト） 8
ラージコンテントフルペイント(LCP)

9
- 5 重要なABT画像のレンダリング		
視覚的な完成度			
- 6 クリティカルでない（非同期）CSSのパース		
- 7 1P JSの実行とハイドレーション
レイジーローディングされたJSチャンク
- 10 ファーストインプットディレイ(FID)			
この順序は直感的に理解できる部分もあるが、以下の点を考慮すると、さらに正当化することができるだろう。

`Prelaod`は、先行するすべてのリソースに対して手動でのプリロードを強制し、また順序の手動キュレーションを引き起こすため、できるだけ避けることを推奨します。
特にフォントについては、重要なフォントを検出するのが難しいため、Preload を避けるべきです。
Font-CSSは理想的にはインライン化すべきです。
別のオリジンからのフォントは、preconnect を使用して取得する必要があります。
他のオリジンからのすべてのリソースには、preconnect を使用することをお勧めします。
これにより、これらのリソースをダウンロードするための接続が事前に確立されます。
重要でないCSSは、ユーザーとの対話が始まる前に取得されるべきです（FID）。
これにより、そのような CSS のその後のレンダリングによるスタイリングの問題を回避することができます。
ネットワーク上のABTイメージの前に、ファーストパーティのJSのフェッチを開始する。JSのダウンロードとパースに時間がかかります。
メインスレッドでのHTMLの解析とABT画像のダウンロードは、1P JSが解析されている間、並行して続けることができます。

ここでの主な関心事は、3Pスクリプトが最適かつ必要な順序でダウンロードされることをどのように確認するかということです。

スクリプトのリクエストは別のドメインに行くので、次の3Pリクエストにはプリコネクトが推奨されます。
これは、ダウンロードを最適化するのに役立ちます。

#1 - 3PリソースをブロックするFCP
#5 - LCPに必要な3PパーソナライズドABTイメージ
#9 - 最初のユーザーインタラクションの前に実行する必要がある3P
#12位 - デフォルトの3P JS
望ましい順序を実現するためには、[NextのScriptLoader](https://github.com/vercel/next.js/discussions/18172)コンポーネントを使用することをお勧めします。
このコンポーネントは、"重要なレンダリングパスを最適化し、外部スクリプトが最適なページロードのボトルネックにならないようにする "ために設計されています。
今回の議論に最も関連する機能は、「Loading Priorities」です。
これにより、さまざまなユースケースをサポートするために、異なるマイルストーンでスクリプトをスケジュールすることができます。

以下は、利用可能なローディング優先度の値です。

After-Interactive : 次の水分補給の後に特定の3Pスクリプトをロードします。これは、できるだけ早く実行したいが、1Pスクリプトの後にタグマネージャ、Ads、またはAnalyticsスクリプトをロードするために使用することができます。
Before-Interactive : 特定の3Pスクリプトを、水分補給の前にロードする。3Pスクリプトを1Pスクリプトの前に実行させたい場合に使用することができる。例：polyfill.io、ボット検出、セキュリティと認証、ユーザー同意管理（GDPR）、など。
Lazy-Onload : 指定した3Pスクリプトよりも他のリソースを優先して、スクリプトを遅延ロードさせる。Google FeedbackのようなCRMコンポーネントや、シェアボタン、コメントなどに使用されるようなソーシャルネットワーク特有のスクリプトに使用することができます。

このように、Next.jsの preconnect、script attributes、ScriptLoader を組み合わせると、すべての script で望ましい順序を得ることができます。

## 結論
アプリを最適化する責任は、使用するプラットフォームの制作者とそれを使う開発者の肩に掛かっています。共通の問題に対処する必要があります。私たちは、内部からシーケンスを簡単にすることを目指します。
さまざまなユースケースに対して試行錯誤を重ねた推奨事項や、Script Loaderのような取り組みが、React-Next.jsスタックの実現に役立っているのです。
次のステップは、新しいアプリが上記の推奨事項に適合していることを確認することでしょう。
