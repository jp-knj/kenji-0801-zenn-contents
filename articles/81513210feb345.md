---
title: ""
emoji: ""
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
# ローディングシーケンスを最適化する
ローディングシーケンスを最適化することで、アプリの操作性を向上させる方法について説明します。

注：この記事は、ChromeのAuroraチーム、特に最適なロード順序を研究しているShubhie Panickerの洞察に大きく影響されています。

ウェブページの読み込みが成功するたびに、いくつかの重要なコンポーネントやリソースが適切なタイミングで利用可能になり、スムーズな読み込み体験を提供します。これにより、ユーザーはアプリケーションのパフォーマンスが優れていることを認識します。この優れたユーザー体験は、一般にコアウェブバイタルの合格にもつながるはずです。

パフォーマンスを測定するために使用されるFirst Content Paint、Largest Contentful Paint、First Input Delayなどの主要な測定基準は、重要なリソースのロード順序に直接依存します。たとえば、ヒーロー画像のような重要なリソースがロードされないと、ページはそのLCPを持つことができません。この記事では、リソースのロード順序とWebバイタルの関係について説明します。その目的は、より良いWebバイタルを実現するために読み込み順序を最適化する方法について、明確な指針を示すことにあります。

理想的な読み込み順序を確立する前に、まず、読み込み順序を正しく設定することがなぜ難しいかを理解しましょう。

## なぜ最適なロードを実現することが難しいのか？
私たちは、多くのパートナー企業のウェブサイトのパフォーマンス分析に携わるユニークな機会を得ました。その結果、さまざまなパートナーのサイトにおいて、ページの効率的な読み込みを悩ませる複数の類似した問題があることがわかりました。

開発者の期待と、ブラウザがページ上のリソースを優先する方法との間には、しばしば決定的なギャップがあります。その結果、最適とは言えないパフォーマンス・スコアになることがよくあります。私たちは、このギャップの原因を突き止めるためにさらに分析を進め、以下のポイントに分析の本質をまとめました。

### 最適でない順序付け

Web Vitalsの最適化には、各メトリクスが何を表しているかを理解するだけでなく、それらが発生する順序や、異なる重要なリソースとどのように関連しているかを理解する必要があります。FCPはLCPの前に発生し、FIDの前に発生します。したがって、FCPを達成するために必要なリソースは、LCPで必要なリソースよりも優先され、次にFIDで必要なリソースが優先されるべきです。

リソースは正しい順序で配列され、パイプライン化されていないことが多い。これは、開発者がメトリクスとリソース負荷の依存関係を認識していないためと思われます。その結果、関連するリソースが、対応するメトリクスがトリガーされる適切なタイミングで利用できないことがある。

例を挙げます。

a) FCPが起動するまでに、LCPを起動するためのヒーロー画像が利用可能であるべきです。
b) LCP が起動する頃には、JavaScript（JS）がダウンロードされ、解析され、インタラクション（FID）のブロックを解除する準備ができている（またはすでに実行されている）べきである。

### ネットワーク/CPUの使用率

また、CPUやネットワークをフルに活用するために、リソースが適切にパイプライン化されていない。その結果、プロセスがネットワークに接続しているときはCPUに「デッドタイム」が発生し、逆にネットワークに接続しているときはCPUに「デッドタイム」が発生します。

この好例が、同時または連続的にダウンロードされるスクリプトです。同時ダウンロードでは帯域幅が分割されるため、すべてのスクリプトをダウンロードするための合計時間は、順次ダウンロードと同時ダウンロードの両方で同じになります。スクリプトを同時ダウンロードする場合、ダウンロード中にCPUが十分に活用されません。しかし、スクリプトを順次ダウンロードする場合、CPUは最初のスクリプトをダウンロードするとすぐに処理を開始できます。この結果、CPUとネットワークの使用率が向上します。

### サードパーティ（3P）製品

3Pライブラリは、多くの場合、Webサイトに共通の機能や特徴を追加するために必要とされます。サードパーティーには、広告、分析、ソーシャルウィジェット、ライブチャット、その他ウェブサイトを強化するエンベッドが含まれます。サードパーティライブラリには、独自のJavaScript、画像、フォントなどが付属しています。

3P製品は通常、消費者サイトの読み込みパフォーマンスを最適化し、サポートするインセンティブを持ちません。JavaScriptの実行コストが高く、インタラクティビティを遅らせたり、他の重要なリソースのダウンロードの邪魔になったりする可能性があります。

3P製品を含む開発者は、パフォーマンスへの影響よりも、機能面で付加する価値に重点を置く傾向があるかもしれません。その結果、3Pリソースは、全体のロードシーケンスにどのように適合するかを十分に考慮することなく、無造作に追加されることがあります。このため、3Pリソースの制御やスケジューリングが難しくなります。

### プラットフォームの癖

ブラウザによって、リクエストの優先順位付けやヒントの実装方法が異なる場合があります。プラットフォームとその癖について深い知識があれば、最適化は容易になります。特定のブラウザに特有の挙動があると、望ましい読み込み順序を一貫して実現することが難しくなります。

この例として、chromium プラットフォームの preload バグが挙げられます。Preload (<link rel=preload>) 命令は、主要なリソースをできるだけ早くダウンロードするよう、ブラウザに指示するために使用できます。これは、そのリソースが現在のページで使用されることが確実な場合にのみ使用されるべきです。Chromium のバグにより、<link rel=preload> で発行されたリクエストは、たとえ優先度が高いものであっても、常に preload スキャナで検出された他のリクエストより先に開始されるような動作が発生します。このような問題は、最適化計画に支障をきたします。

### HTTP2 の優先順位付け

プロトコル自体には、リソースの順序や優先順位を調整するためのオプションやノブはあまり用意されていません。たとえより優れた優先順位付けのプリミティブが利用可能になったとしても、HTTP2 の優先順位付けには、最適な順序付けを難しくする根本的な問題があります。主に、サーバーや CDN が個々のリソースへのリクエストにどのような順番で優先順位をつけるかを予測することはできません。CDN の中にはリクエストを再優先するものもあれば、部分的な優先順位付け、欠陥のある優先順位付け、あるいは優先順位付けを行わないものを実装しているものもあります。

### リソースレベルの最適化

効果的な順序付けを行うには、順序付けされるリソースが最適に提供され、素早く読み込まれる必要があります。重要なCSSはインライン化し、画像は正しいサイズにし、JSはコードを分割してインクリメンタルに配信する必要があります。

フレームワーク自体には、コードを分割し、JSやデータをインクリメンタルに提供するための構成が欠けています。ユーザーは、1P JSの大きな塊を分割するために、以下のいずれかに依存する必要があります。

Modern React (Suspense / Concurrent mode / Data Fetching) - これはまだ実験的にしか利用できません。
ダイナミックインポートによるレイジーローディング - これは直感的ではなく、開発者はコードを分割する境界を手動で特定する必要があります。
コードを分割する場合、開発者は、粒度とパフォーマンスのトレードオフのために、チャンクのちょうどよい粒度を達成する必要があります。

## より高い粒度が望ましい理由は

個々のルートとその後のユーザーインタラクションに必要なJSを最小化する。
共通の依存関係のキャッシュを可能にする。これにより、ライブラリに変更があった場合でも、バンドル全体を再取得する必要がなくなります。
同時に、コード分割の粒度を上げすぎると、小さなチャンクが多すぎて個々のチャンクの圧縮率が下がり、ブラウザのパフォーマンスに影響するため、好ましくないことがあります。

リソースの最適化には、デッドコードや未使用のコードを排除することも必要です。不要な JS や時代遅れの JS がモダンブラウザに同梱されていることがありますが、これはパフォーマンスに悪影響を及ぼします。ES5 に変換され、polyfill にバンドルされた JS は、モダンブラウザには不要です。ライブラリやnpmパッケージは、ESモジュール形式で公開されていないことが多い。そのため、バンドル担当者がツリーシェイクや最適化を行うことが困難である。

お気づきかもしれませんが、これらの問題は、特定のリソースやプラットフォームに限定されるものではありません。これらの問題を回避するためには、技術スタック全体を理解し、最適な指標を達成するためにどのように異なるリソースを合体させることができるかを理解することが必要です。全体的な最適化戦略を定義する前に、個々のリソース要件がいかにして目的を達成できないかを見てみましょう。

#リソースの詳細 - 関係、制約、および優先順位 
前節では、FCPやLCPのような特定のイベントが発生するために、特定のリソースが必要であるという例をいくつか挙げました。ここでは、そのような依存関係をすべて理解してから、それらを扱う方法について説明します。以下は、理想的なシーケンスを定義する前に考慮する必要がある、推奨、制約、およびゲッチャのリソース別のリストです。

## クリティカルCSS

Critical CSSとは、FCPに必要な最低限のCSSのことです。このようなCSSは、他のCSSファイルからインポートするのではなく、HTML内にインライン化するのが望ましい。ルートに必要なCSSのみを随時ダウンロードし、クリティカルなCSSはすべてそれに応じて分割する必要がある。

インライン化が不可能な場合は、重要なCSSはあらかじめロードしておき、ドキュメントと同じオリジンから提供する必要があります。複数のドメインから重要なCSSを提供したり、Google Fontsのようなサードパーティの重要なCSSを直接使用することは避けてください。自分のサーバーをサードパーティーのCSSのプロキシとして機能させることもできます。

CSSの取得に遅延が生じたり、CSSの取得順序が正しくない場合、FCPやLCPに影響を与える可能性があります。これを避けるため、インライン化されていないCSSは、ネットワーク上で1P JSやABTイメージよりも優先的に処理され、順序付けられるべきではないでしょうか。

インライン CSS が多すぎると、HTML が肥大化し、メイン スレッドでのスタイル解析時間が長くなる可能性があります。これは FCP に損害を与える可能性があります。そのため、何が重要かを特定し、コードを分割することが重要です。

インライン化された CSS はキャッシュされません。この回避策として、キャッシュ可能な CSS に対して重複したリクエストを行うことができます。ただし、この場合、全ページのレイアウトが複数になり、FIDに影響を与える可能性があることに注意してください。

## フォント

重要なCSSと同様に、重要なフォントのCSSもインライン化する必要があります。インライン化が不可能な場合は、プレコネクトを指定してスクリプトを読み込む必要があります。Googleフォントや別ドメインのフォントなど、フォントの取得に時間がかかると、FCPに影響が出ることがあります。プレコネクトは、これらのリソースへの接続を早めにセットアップするようにブラウザに指示します。

フォントのインライン化は、HTMLを著しく肥大化させ、他の重要なリソースのフェッチを開始するのを遅らせる可能性があります。フォント・フォールバックは、FCPのブロックを解除し、テキストを利用可能にするために使用される場合があります。しかし、フォントフォールバックを使用すると、フォントがジャンプするため、CLSに影響を与える可能性があります。また、実際のフォントが到着したときに、メインスレッドで大規模なスタイルおよびレイアウトタスクが発生する可能性があるため、FID にも影響を与える可能性があります。

## Above the Fold（ABT）画像

ページロード時にビューポート内にあるため、ユーザーに最初に表示される画像のことです。ABT画像の特別なケースは、ページのヒーロー画像です。ABT画像はすべて、サイズを調整する必要があります。サイズ調整されていない画像は、完全にレンダリングされたときにレイアウトが変化するため、CLSの指標に影響を与えます。ABT 画像のプレースホルダーは、サーバーによってレンダリングされるべきです。

遅延したヒーロー画像や空白のプレースホルダーは、LCPの遅延を招きます。さらに、プレースホルダのサイズが実際のヒーロー画像の固有サイズと一致せず、画像が置き換えでオーバーレイされない場合、LCPは再トリガーされます。理想的には、ABT画像によるFCPへの影響はないはずですが、実際には、画像がFCPを発生させることがあります。

## BTF（Below the Fold）画像

ページロード時にユーザーからすぐに見えない画像です。そのため、レイジーローディングの理想的な候補となります。これにより、ページ上で必要とされる1P JSや重要な3Pと競合することがありません。もしBTF画像が1P JSや重要な3Pリソースよりも先にロードされると、FIDが遅延してしまいます。

## 1P JavaScript

1P JSは、アプリケーションのインタラクションレディネスに影響を与える。画像と3P JSの背後にあるネットワークと、3P JSの背後にあるメインスレッドで、遅延する可能性があります。そのため、ネットワーク上ではABTイメージの前にロードを開始し、メインスレッドでは3P JSの前に実行されるべきです。1P JSは、サーバーサイドでレンダリングされるページでは、FCPとLCPをブロックしない。

## 3P JavaScript

3P sync script in HTML head は CSS & font parsing をブロックする可能性があり、その結果 FCP もブロックされる可能性があります。また、head内の同期スクリプトは、HTMLボディのパースもブロックする。メインスレッドでの3Pスクリプトの実行は、1Pスクリプトの実行を遅らせ、ハイドレーションとFIDを押し出す可能性があります。そのため、3Pスクリプトのロードには、より良い制御が必要です。

これらの推奨事項や制約事項は、技術スタックやブラウザに関係なく、一般的に適用されます。推奨事項であるものが、どのように制約になり得るかに注意してください。例えば、フォントやCSSのインライン化は素晴らしいことですが、やり過ぎると肥大化の原因になります。コツは、「Too little Too late」と「Too much Too soon」の間のバランスを見つけることです。

次の図は、さまざまなリソースを読み込む際のChromeの優先順位を理解するためのものです。優先順位に関する情報とリソースの種類に関する議論を組み合わせることで、次のセクションで提案する読み込み順序をより理解することができます。

## 以下は、この表から得られる重要なポイントである。

CSSとFontsは最も高い優先度でロードされます。これは、重要なCSSとフォントの優先順位付けに役立つはずです。
スクリプトは、ドキュメント内の位置と、非同期、遅延、ブロックのいずれであるかによって、優先順位が異なります。最初の画像 (またはドキュメントの初期の画像) の前に要求されたブロッキングスクリプトは、最初の画像が取得された後に要求されたブロッキングスクリプトよりも高い優先順位が与えられます。非同期/遅延/インジェクションのスクリプトは、ドキュメント内の位置に関係なく、最も低い優先順位となります。したがって、async と defer に適切な属性を使用することで、さまざまなスクリプトに優先順位をつけることができます。
可視でビューポート内にある画像は、ビューポート内にない画像（Net: Lowest）よりも高い優先度（Net: Medium）を持ちます。これにより、ABT画像をBTF画像よりも優先させることができます。
それでは、上記の詳細をすべてまとめて、最適な読み込み順序を定義する方法を見ていきましょう。

理想的なローディングシーケンスとは？
このような背景から、1Pと3Pの両方のリソースの読み込みを最適化するための読み込み順序を提案することができます。提案する順序は、Next.jsのServer Side Rendering (SSR)を参考に最適化を図ります。

現状その
これまでの経験から、最適化前のNext.jsのSSRアプリケーションで観測された典型的な読み込み順序は次のとおりです。

CSS CSSはJSの前にロードされるが、インライン化されない。
JavaScript 1P JSがプリロードされる
3P JSは管理されず、ドキュメント内のどこでもレンダーブロッキングを起こす可能性があります。
フォント フォントはインラインでもプリコネクトでもありません。
フォントは外部スタイルシートを介して読み込まれるため、読み込みに時間がかかる
フォントは表示ブロックになる場合とならない場合があります。
画像 ヒーローの画像は優先されない
ABT画像、BTF画像ともに最適化されていない
以下は、あるパートナーサイトのこのようなシーケンスの一例です。このロードシーケンスに関するポジティブな点とネガティブな点を注釈として含んでいます。