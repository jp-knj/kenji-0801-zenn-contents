---
title: "ローディングを最適に"
emoji: ""
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
# ローディングシーケンスを最適化する
ローディングシーケンスを最適化することで、アプリの操作性を向上させる方法について説明します。

Webページの読み込みが成功するたびに、重要なコンポーネントやリソースが適切なタイミングで利用可能になり, スムーズな読み込みをします。
パフォーマンスが良いと、一般に[Core Web Vital](https://web.dev/vitals/)の基準をクリアすることになります

パフォーマンスを測定するために使用される
- FCP : First Content Paint
  - 「最初にコンテンツを表示する」までにどれくらいの時間がかかったのかを表す。
- LCP : Largest Contentful Paint 
  - 「最も大きなコンテンツ(画像など)を表示する」までにどれくらいの時間がかかったのかを表す。
  - ページが最初にロードを開始してから 2.5秒以内にLCPが発生する必要があります。
- FID : First Input Delay

３つの測定基準は、読み込みの順序に大きく影響されます。

たとえば、ヒーロー画像のような重要なリソースがロードされないと、ページはそのLCPを持つことができません。
この記事では、リソースの読み込まれる順番とWeb vitalsの関係について説明します。

その目的は、より良いWeb vitalsを実現するために読み込み順序を最適化する方法について、明確な指針を示すことにあります。

理想的な読み込み順序を確立する前に、まず読み込み順序を正しく設定することがなぜ難しいかを理解しましょう。

## なぜ最適なロードを実現することが難しいのか？
最適ではないパフォーマンス・スコアになってしまった場合、複数の要点が挙がります。

### 最適でない順序付け
Web Vitalsの最適化には、
測定が何を表しているかを理解するだけでなく、
それらが発生する順序や、
各ファイルはどのように関連しているかを理解する必要があります。

FCP → LCP → FID
なので、FCPを達成するために必要なリソースは、LCPで必要なリソースよりも優先され、次にFIDで必要なリソースが優先されるべきです。

リソースは正しい順序で配列され、パイプライン化されていないことが多く、がメトリクスとリソース負荷の依存関係を認識していないためと思われます。
その結果、関連するリソースが、対応するメトリクスがトリガーされる適切なタイミングで利用できないことがある。

例を挙げます。

a) FCPが起動するまでに、LCPを起動するためのヒーロー画像が利用可能であるべきです。
b) LCP が起動する頃には、JavaScript が `loading`され、`parse`され、インタラクション（FID）のブロックを解除する準備ができている（すでに実行されている）べきである。

### ネットワーク/CPUの使用率

また、CPUやネットワークをフルに活用するために、リソースが適切にパイプライン化されていない。
その結果、プロセスがネットワークに接続しているときはCPUに「デッドタイム」が発生し、逆にネットワークに接続しているときはCPUに「デッドタイム」が発生します。

この好例が、同時または連続的にダウンロードされるスクリプトです。
同時ダウンロードでは帯域幅が分割されるため、すべてのスクリプトをダウンロードするための合計時間は、順次ダウンロードと同時ダウンロードの両方で同じになります。
スクリプトを同時ダウンロードする場合、ダウンロード中にCPUが十分に活用されません。
しかし、スクリプトを順次ダウンロードする場合、CPUは最初のスクリプトをダウンロードするとすぐに処理を開始できます。
この結果、CPUとネットワークの使用率が向上します。

### サードパーティライブラリ

サードパーティライブラリは、多くの場合、Webサイトに共通の機能や特徴を追加するために必要とされます。

3P製品は通常、消費者サイトの読み込みパフォーマンスを最適化し、サポートするインセンティブを持ちません。
JavaScriptの実行コストが高く、インタラクティビティを遅らせたり、他のhtml/css/jsファイルのダウンロードの邪魔になったりする可能性があります。

Webサイトのパフォーマンスへの影響よりも、機能で価値に重点を置く傾向があるかもしれません。
その結果、全体の読み込み順序を十分に考慮することなく、無造作に追加されることがあります。
このため、サードパーティライブラリの制御やスケジューリングが難しくなります。

### プラットフォームの癖

ブラウザによって、リクエストの優先順位付けやヒントの実装方法が異なる場合があります。
プラットフォームとその癖について深い知識があれば、最適化は容易になります。
特定のブラウザに特有の挙動があると、望ましい読み込み順序を一貫して実現することが難しくなります。

この例として、chromium (Google Chromeの元Webブラウザ)の preload バグが挙げられます。
Preload `<link rel=preload>` 命令は、主要なリソースをできるだけ早くダウンロードするよう、ブラウザに指示するために使用できます。
これは、そのリソースが現在のページで使用されることが確実な場合にのみ使用されるべきです。
Chromium のバグにより、<link rel=preload> で発行されたリクエストは、たとえ優先度が高いものであっても、常に preload スキャナで検出された他のリクエストより先に開始されるような動作が発生します。
このような問題は、最適化計画に支障をきたします。

### HTTP2 の優先順位付け

プロトコル自体には、リソースの順序や優先順位を調整するためのオプションは充実されていません。
たとえより優れた優先順位付けのプリミティブが利用可能になったとしても、HTTP2 の優先順位付けには、最適な順序付けを難しくする根本的な問題があります。
主に、サーバーや CDN が個々のリソースへのリクエストにどのような順番で優先順位をつけるかを予測することはできません。
CDN の中にはリクエストを再優先するものもあれば、部分的な優先順位付け、欠陥のある優先順位付け、あるいは優先順位付けを行わないものを実装しているものもあります。

### リソースレベルの最適化
効果的な順序付けを行うには、順序付けされるリソースが最適に提供され、素早く読み込まれる必要があります。
`

読み込みファイルを分割するために、以下のいずれかの手法を使用します。

Modern React の機能(Suspense / Concurrent mode / Data Fetching) 
`Dynamic import`による`lazy loading`
コードを分割する場合、フロントエンドエンジニアは、粒度とパフォーマンスのトレードオフのために、`chunk`のちょうどよい粒度を定める必要があります。

## より高い粒度が望ましい理由は

個々のルートとその後のユーザーインタラクションに必要なJSを最小化する。
共通の依存関係のキャッシュを可能にする。これにより、ライブラリに変更があった場合でも、バンドル全体を再取得する必要がなくなります。
同時に、コード分割の粒度を上げすぎると、小さなチャンクが多すぎて個々のチャンクの圧縮率が下がり、ブラウザのパフォーマンスに影響するため、好ましくないことがあります。

リソースの最適化には、未使用で不要なコードを排除することも必要です。
不要な JS や時代遅れの JS がモダンブラウザに同梱されていることがありますが、これはパフォーマンスに悪影響を及ぼします。
ES5に変換され、polyfillにバンドルされたJS は、モダンブラウザには不要です。
ライブラリやnpmパッケージは、ESモジュール形式で公開されていないことが多い。
ツリーシェイクや最適化を行うことが困難である。

お気づきかもしれませんが、これらの問題は、特定のリソースやプラットフォームに限定されるものではありません。
これらの問題を回避するためには、技術スタック全体を理解し、最適な指標を達成するためにどのように異なるリソースを合体させることができるかを理解することが必要です。
全体的な最適化戦略を定義する前に、個々のリソース要件がいかにして目的を達成できないかを見てみましょう。

#リソースの詳細 - 関係、制約、および優先順位 

前節では、FCPやLCPのような特定のイベントが発生するために、特定のリソースが必要であるという例をいくつか挙げました。
ここでは、そのような依存関係をすべて理解してから、それらを扱う方法について説明します。
以下は、理想的なシーケンスを定義する前に考慮する必要がある、推奨、制約、およびゲッチャのリソース別のリストです。

## クリティカルCSS - 必要最低限なCSS
[Critical CSS](https://web.dev/extract-critical-css/)とは、必要な最低限のCSSのことです。
他のCSSファイルからimportするのではなく、HTML内にインライン化するのが望ましいとされています。
例えば、ユーザーのファーストビューに必要なスタイルだけを `<style> タグ`を使ってインライン化すると、リソースサイズの肥大化を最小限に抑えながら、かつより良いパフォーマンスの改善ができます。
```html
<head>
  <style>
      body{background:#fff;color:#000;margin:0}.link{color:#1a0dab}.link{border-collapse:collapse}.list items{padding:0}.item{color:#000}....
  </style>
</head>
```
このようなCSSは、 ルートに必要なCSSのみを随時ダウンロードし、Critical CSSはすべてそれに応じて分割する必要がある。

インライン化が難しい場合は、Critical CSSはあらかじめロードしておき、ドキュメントと同じオリジンから提供する必要があります。
複数のドメインから、Critical CSSを提供したり、Google Fontsのよう外部のCriticalCSSを直接使用することは避けてください。

自分のサーバーをサードパーティーのCSSのプロキシとして機能させることもできます。

CSSの取得に遅延が生じたり、CSSの取得順序が正しくない場合、FCPやLCPに影響を与える可能性があります。
これを避けるため、インライン化されていないCSSは、ネットワーク上で1P JSやABTイメージよりも優先的に処理され、順序付けられるべきではないでしょうか。

### インラインCSSは多すぎてもよくない理由
`インラインCSS` が多すぎると、HTML が肥大化し、style を **parse**(構文解析) の時間が長くなる可能性があり、 FCP に損害を与える可能性があります。
そのため、何が必要最低限で、コードを分割することが重要です。インラインCSSはファイルのリクエスト数を減らすための手段の一つです

あとCSSをインライン化すると、ブラウザキャッシュは使えません。
しかし、ブラウザキャッシュはサーバーからの受け渡し時間を短縮するだけで、ブラウザキャッシュはCSSファイルを読み込みますが取得しないため、
2度目以降もファイルを読み込むのは変わらず、CSSのファイル数分だけ読み込みが入ります。

CSSについては現在のパフォーマンスからボトルネックを洗い出しつつ、最適化させるのが正しい高速化設定の使い方だと思います。

## フォント
Critical CSSと同様に、必要なフォントのCSSもインライン化する必要があります。
フォントのインライン化が難しい場合は、[preconnect](https://web.dev/uses-rel-preconnect/)を指定して script を読み込む必要があります。
Googleフォントや外部フォントなど、フォントの取得に時間がかかると、FCPに影響が出ることがあります。
preconnect は、これらのリソースへの接続を早めに読み込むようにブラウザに指示します。

フォントのインライン化は、HTMLを著しく肥大化させ、他のファイルやデータ取得を遅らせる可能性があります。
Webフォントを使用する場合は原則、フォントをダウンロードするまでテキストが表示されないFOIT（Flash of Invisible Text）か、
最初はフォールバック用のシステムフォントを使用し、ダウンロードが済んだらWebフォントに更新するFOUT（Flash of Unstyled Text）のどちらかを選ぶ必要があります。
正直に言って、どちらの選択肢もあまり満足の行くものではなく、どちらかが特に有効的な選択ということではないようです。

参考: [MDN:preconnect](https://developer.mozilla.org/ja/docs/Web/HTML/Link_types/preconnect)

## Above the Fold（ABT）画像
`Above the Fold画像`とはWebページの読み込み時に`viewport内`にある最初に表示される画像のことです。
Above the Fold画像の代表的な例は
- ページのhero画像
Above the Fold画像はすべて、sizeを調整する必要があります。
size調整されていない画像 は、レンダリングされたときにレイアウトが変化するため、[CLS（Cumulative Layout Shift）]の指標に悪い影響を与えます。
Above the Fold画像の初期表示される内容は、サーバーサイドによってレンダリングされるべきです。

遅延したヒーロー画像や空白の初期表示される内容は、LCPの遅延を招きます。
さらに、初期表示される内容のsizeが実際のhero画像の固有サイズと一致せず、
画像が置き換えでオーバーレイされない場合、LCPは再トリガーされます。
理想的には、ABT画像によるFCPへの影響はないはずですが、実際には、画像がFCPを発生させることがあります。

## BTF（Below the Fold）画像
Webページの読み込み時にviewport外ですぐに見えない画像です。
そのため、`lazy-laoding`などの手法を選択するのが選択する。
これにより、ページ上で必要とされる1P JSや重要な3Pと競合することがありません。
もしBTF画像が1P JSや重要な3Pリソースよりも先にロードされると、FIDが遅延してしまいます。

## 内部JavaScript

1P JSは、アプリケーションのインタラクションレディネスに影響を与える。
画像と3P JSの背後にあるネットワークと、3P JSの背後にあるメインスレッドで、遅延する可能性があります。
そのため、ネットワーク上ではAbove the Fold画像の前に読み込みをはじめ、外部から読み込まれたJavascriptファイルよりも、先に内部ファイルを読み込むことが重要です。
内部JavaScriptファイルは、サーバーサイドでレンダリングされるページでは、FCPとLCPをブロックしない。

## 外部JavaScript/サードパーティライブラリ

3P sync script in HTML head は CSS & font parsing をブロックする可能性があり、その結果 FCP もブロックされる可能性があります。
また、head内の同期スクリプトは、HTMLボディのパースもブロックする。
メインスレッドでの3Pスクリプトの実行は、1Pスクリプトの実行を遅らせ、ハイドレーションとFIDを押し出す可能性があります。
そのため、3Pスクリプトのロードには、より良い制御が必要です。

これらの推奨事項や制約事項は、技術スタックやブラウザに関係なく、一般的に適用されます。
推奨事項であるものが、どのように制約になり得るかに注意してください。
例えば、フォントやCSSのインライン化は素晴らしいことですが、やり過ぎると肥大化の原因になります。
コツは、「Too little Too late」と「Too much Too soon」の間のバランスを見つけることです。

次の図は、さまざまなリソースを読み込む際のChromeの優先順位を理解するためのものです。
優先順位に関する情報とリソースの種類に関する議論を組み合わせることで、次のセクションで提案する読み込み順序をより理解することができます。

## 読み込み時の優先度を列挙する

1. CSSとFontsは最も高い優先度でロードされます。これは、CriticalCSS(インラインCSS)とフォントの優先順位付けに役立つはずです。
2. script は、document内の位置と、async, defer, blocking のいずれであるかによって、優先順位が異なります。
3. 最初の画像 (またはドキュメントの初期の画像) の前に要求されたblocking-scriptは、最初の画像が取得された後に要求されたblocking-scriptよりも高い優先順位が与えられます。
非同期/遅延/injection のスクリプトは、ドキュメント内の位置に関係なく、最も低い優先順位となります。したがって、[async と defer](https://javascript.info/script-async-defer) に適切な属性を使用することで、さまざまなスクリプトに優先順位をつけることができます。
可視で viewport内 にある画像は、viewport内にない画像（Net: Lowest）よりも高い優先度（Net: Medium）を持ちます。
これによりAbove the Fold（ABT）画像をBTF（Below the Fold）画像よりも優先させることができます。

それでは、上記の詳細をすべてまとめて、最適な読み込みをするようにしていきましょう。

## 理想的なローディングシーケンスとは？
このような背景から、1Pと3Pの両方のリソースの読み込みを最適化するための読み込み順序を提案することができます。
提案する順序は、Next.jsのServer Side Rendering (SSR)を参考に最適化を図ります。

### 現状
これまでの経験から、最適化前のNext.jsのSSRアプリケーションで観測された典型的な読み込み順序は次のとおりです。

CSS: CSSはJSの前にロードされるが、インライン化されない。
JavaScript: 内部JavaScriptファイルがプリロードされる / 外部JavaScripファイルは管理されず、ドキュメント内のどこでもレンダーブロッキングを起こす可能性があります。
font: フォントはインラインでもpreconnectでもありません。フォントは外部スタイルシートを介して読み込まれるため、読み込みに時間がかかる。 フォントは表示ブロックになる場合とならない場合があります。
images: ヒーローの画像は優先されない
ABT画像、BTF画像ともに最適化されていない

以下は、あるパートナーサイトのこのようなシーケンスの一例です。
このロードシーケンスに関するポジティブな点とネガティブな点を注釈として含んでいます。

## 理想的なローディングシーケンスとは？
このような背景から、1Pと3Pの両方のリソースの読み込みを最適化するための読み込み順序を提案することができます。
提案する順序は、Next.jsのServer Side Rendering (SSR)を参考に最適化を図ります。

### 現状
これまでの経験から、最適化前のNext.jsのSSRアプリケーションで観測された典型的な読み込み順序は次のとおりです。

CSS CSSはJSの前にロードされるが、インライン化されない。
JavaScript 1P JSがプリロードされる
3P JSは管理されず、ドキュメント内のどこでもレンダーブロッキングを起こす可能性があります。
フォント フォントはインラインでもプリコネクトでもありません。
フォントは外部スタイルシートを介して読み込まれるため、読み込みに時間がかかる
フォントは表示ブロックになる場合とならない場合があります。
画像 ヒーローの画像は優先されない
ABT画像、BTF画像ともに最適化されていない

以下は、あるパートナーサイトのこのようなシーケンスの一例です。このロードシーケンスに関するポジティブな点とネガティブな点を注釈として含んでいます。

## 3Pを使用しない場合の提案シーケンス
以下は、先に述べた制約をすべて考慮したロードシーケンスである。
まず、3Pを使わないシーケンスに取り組みましょう。
次に、このシーケンスで3Pリソースをどのようにインターリーブすることができるかを見ていきます。
なお、ここではGoogle Fontsを1Pとみなしている。

| メインスレッドにおけるイベントの順序(ブラウザ)       | ネットワーク上のリクエストの順序                                               |
|--------------------------------|----------------------------------------------------------------|
| 1.HTMLを解析する                    | 小さなインラインJavaScriptを読み込み                                        |
| 2.小さなインラインJavaScriptを実行        | インラインCSS(Critical CSS) / preloadされた外部CSSファイルを読み込み              |
|                                | インラインfont(Critical font) / preconnectされた外部fontファイルを読み込み        |
| 3. 最初のコンテンツを描画                 | インラインfont(Critical font) / preconnectされた外部fontファイルを読み込み        |
| 4. 最初のコンテンツを描画                 | 内部JavaScripファイル<br/>preconnectされたviewport内の画像<br/>viewport外の画像 |
| 5. preconnectされたviewport内の画像を描画 |                                                                |
| 6. 外部CSSファイルを非同期で読み込み          | 外部CSSファイルを非同期で読み込み                                             |
| 7. 内部JavaScriptファイルとhydrate    | Lazy-loaded JavaScriptファイル                                     |

この順序は直感的に理解できる部分もあるが、以下の点を考慮すれば、さらに正当化できるだろう。

preloadは、先行するすべてのリソースに対して手動でのpreloadを強制し、また順序の手動キュレーションを引き起こすため、できるだけ避けることを推奨します。特にフォントについては、重要なフォントを検出するのが難しいため、prelaodを避けるべきです。
Font-CSSは理想的にはインライン化すべきです。別のオリジンからのフォントは、preconnect を使用して取得する必要があります。
他のオリジンからのすべてのリソースには、preconnect を使用することをお勧めします。これにより、これらのリソースをダウンロードするための接続が事前に確立されます。
Critical CSSは、ユーザーとの対話が始まる前に取得されるべきです（FID）。これにより、そのような CSS のその後のレンダリングによるスタイリングの問題を回避することができます。
ネットワーク上のAbove the Fold画像(viewport内の画像)の前に、内部JavaScriptファイルのフェッチを開始する。JavaScriptの読み込みと解析に時間がかかります。
メインスレッドでのHTMLの解析とのAbove the Fold画像の読み込みは、内部JavaScriptが解析されている間、並行して続けることができます。

望ましい順序を実現するためには、[NextのScriptLoader](https://github.com/vercel/next.js/discussions/18172)コンポーネントを使用することをお勧めします。
このコンポーネントは、"重要なレンダリングパスを最適化し、外部script が最適なpageload のボトルネックにならないようにする "ために設計されています。
今回の議論に最も関連する機能は、「Loading Priorities」です。
これにより、さまざまなユースケースをサポートするために、異なるマイルストーンでスクリプトをスケジュールすることができます。

### 以下は、利用可能なローディング優先度の値です。

`After-Interactive` : 次の水分補給の後に特定の3Pスクリプトをロードします。これは、できるだけ早く実行したいが、1Pスクリプトの後にタグマネージャ、Ads、またはAnalyticsスクリプトをロードするために使用することができます。
`Before-Interactive` : 外部JavaScriptファイルを、水分補給の前にロードする。3Pスクリプトを1Pスクリプトの前に実行させたい場合に使用することができる。例：polyfill.io、ボット検出、セキュリティと認証、ユーザー同意管理（GDPR）、など。
`Lazy-Onload` : 指定した外部JavaScriptファイルよりも他のリソースを優先して、スクリプトを遅延ロードさせる。Google FeedbackのようなCRMコンポーネントや、シェアボタン、コメントなどに使用されるようなソーシャルネットワーク特有のscript に使用することができます。

このように、Next.jsの preconnect、script attributes、ScriptLoader を組み合わせると、すべての script で望ましい読み込み順序をする。

## 結論
アプリを最適化する責任は、使用するプラットフォームの制作者とそれを使う開発者の肩に掛かっています。共通の問題に対処する必要があります。私たちは、内部からシーケンスを簡単にすることを目指します。
さまざまなユースケースに対して試行錯誤を重ねた推奨事項や、Script Loaderのような取り組みが、React-Next.jsスタックの実現に役立っているのです。
次のステップは、新しいアプリが上記の推奨事項に適合していることを確認することでしょう。
