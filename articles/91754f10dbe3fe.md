---
title: "パフォーマンス向上を考える時に知って損はないTree shaking"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['javascript', 'webpack', 'rollup']
published: false
---

アプリケーションのどこにも使用されていないコードをバンドルに追加してしまうことがあります。このデッドコードを削除することで、バンドルのサイズを小さくし、不必要に多くのデータを読み込むことを防ぐことができます。バンドルに追加する前にデッドコードを削除するプロセスをツリーシェイクと呼びます。

math モジュールのような単純なモジュールではツリーシェイクは有効ですが、ツリーシェイクが厄介なケースもあります。

コンセプト
ツリーシェイキングは、最終的なJavaScriptバンドルから使われることのないコードを削除することを目的としています。正しく行えば、JavaScript バンドルサイズを縮小し、ダウンロード、パース、（場合によっては）実行時間を短縮することができます。モジュール バンドル (webpack や Rollup など) を使用するほとんどのモダンな JavaScript アプリでは、バンドルは死んだコードを自動的に削除するものだと思われます。

アプリケーションとその依存関係を抽象的な構文木として考えてみましょう（私たちは構文木を「揺さぶって」最適化したいのです）。ツリーの各ノードは、あなたのアプリに機能を与える依存関係です。ツリーシェイクでは、入力ファイルはグラフとして扱われます。グラフの各ノードはトップレベルのステートメントで、コードでは「パート」と呼ばれる。ツリーシェイキングはグラフの走査であり、エントリポイントから始まり、走査されたパスがあればそれをインクルードするためにマークする。

すべてのコンポーネントは、シンボルを宣言し、シンボルを参照し、他のファイルに依存することができます。部品」であっても、副作用があるかないかはマークされる。例えば、let firstName = 'Jane' というステートメントは、foo が必要なければ、観察される違いなしに削除することができるため、副作用はありません。しかし、let firstName = getName() というステートメントには副作用があります。なぜなら、たとえ firstName を必要とするものがなくても、コードの意味を変えずに getName() の呼び出しを削除することができないからです。

インポート
ES2015 のモジュール構文（import と export）で定義されたモジュールのみ、ツリーシェイクが可能です。モジュールのインポート方法によって、そのモジュールがツリーシェイク可能かどうかが決まります。

ツリーシェイクは、エントリーポイントファイルの副作用のある部分をすべて訪れることから始まり、新しいセクションに到達するまでグラフのエッジをトラバースするように進みます。探索が完了すると、JavaScript のバンドルには、探索中に到達した部分のみが含まれます。他の部分は省かれます。例えば、次のような utilities.js ファイルを定義するとしよう。

エクスポート関数 read(props) {
return props.book
}

エクスポート関数 nap(props) {
return props.winks
}
そして、次のようなindex.jsファイルができあがります。

インポート { read } from 'utilities'.

イベントハンドラ = (e) => {
read({ book: e.target.value }) とする。
}
この例では、nap() は重要ではないので、バンドルに含めません。

サイドエフェクト
ES6モジュールをインポートする場合、そのモジュールは即座に実行されます。モジュールのexportをコード内のどこにも参照していないのに、実行中にモジュール自体がグローバルスコープに影響を与えることがあります（たとえばポリフィルやグローバルスタイルシートなど）。これは副作用と呼ばれます。モジュール自体のexportを参照しているわけではありませんが、そもそもモジュールがexportされた値を持っている場合、そのモジュールはimportされる際に特別な動作をするため、tree-shakeすることができないのです

Webpackのドキュメントに、ツリーシェイクに関するわかりやすい説明と、ツリーシェイクを壊さないようにするための方法が書かれています。