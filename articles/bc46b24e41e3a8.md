---
title: "呼び出し可能ではないエラー対応"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['typescript', 'エラー']
published: true
---
# はじめに
業務の実装で`This expression is not callable. Type String has no call signatures`というエラーメッセージと遭遇したため、備忘録として記述します。

## エラーメッセージを理解する
`This expression is not callable. Type String has no call signatures`

このエラーメッセージは以下の場合に発生します。
- `String`型を関数として呼び出した時
- 関数を`String`型として型推論した時

▼具体例(`String`型を関数として呼び出した時)
```typescript:index.ts
const string = 'write something';

string(); // エラーが発生する
```

ですが、以下の場合は実行できます。
```typescript:index.ts
const string = 'write something';

console.log(string.toUpperCase()); // エラーは発生せず、実行される 
```
`string()`ではなく、`build-in methods`で参照すると実行されるようですね。

▼ 具体例 (関数を`String`型として型推論した時)
```typescript:index.ts
function exampleFunction (): any {
  return (a: number, b: number) => {
    return a + b;
  };
}

const result = exampleFunction() as string;
result(50, 50); // エラーが発生する
```

変数の`result`に関数が格納されていても、
格納されている値の型推論は`String`型にしてしまっています。

当然、実行はできずにエラーを発生してしまっています。

## 遭遇した時の対処
- 関数として呼び出している値が実際の関数であることを確認したでしょうか？
- 関数が正しく型推論されているでしょうか？

## 最後に
このようなことが発生するので`as`を使用しないという理想に近づいていきたいですね。

以下の型エイリアスやインターフェースを熟知していきたいです。
```typescript:index.ts
// 型エイリアス
type ExampleFunction = (a: number, b: number) => number;
const exampleFunction: ExampleFunction = (a, b) => a + b;
console.log(funcA(25, 25));

// インターフェース
interface ExampleFunction {
  (a: number, b: number): number;
}️ 
const exampleFunction: ExampleFunction = (a, b) => a + b;
```