---
title: "<Card.Root> のように実装すべきなのか"
emoji: "📑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---
## はじめに
`<Card.Root>`のような記述を見かけることがあります。ですがReact Server Componentの文脈では、`<Card.Root>` のような記述は避けるべきとされています。なぜでしょうか。

`<Card.Root>`のような記述は"dot"を使用してオブジェクトのプロパティにアクセスする方法を指します。dot notationと呼ばれる記法です。dot notationに関するissueを見かけたので、何が起きているのかを調べてみました。

## 代表的なdot notationの例
例えば、React Contextを使ったとき、`ThemeContext`というトップレベルコンポーネントがあり、それに関連する `Provider`というサブコンポーネントが`ThemeContext.Provider`のようにdot表記で参照されるのです。
```jsx
import { createContext, useContext } from 'react';

const Theme = createContext(null);

function App({ children }) {
    return (
        <ThemeContext.Provider value="dark">
            {children}
        </ThemeContext.Provider>
    );
}

function Header() {
    const theme = useContext(Theme);
    return <header style={{ color: theme === 'dark' ? 'white' : 'black' }}>Header</header>;
}
```

## dot notation で実装をすると何が起こるのか
dot notationで実装をすると、RSCの文脈で問題が発生します。
例えば、以下のようなコードがあるとします。
```jsx
// components/card.tsx
function Card() {}

Card.Header = function Header() {}
Card.Body = function Body() {}
Card.Footer = function Footer() {}

export default Card;

// example/card.tsx
import { Card } from "../components/card"

export const BasedCard = () => {
    return (
        <Card>
            <Card.Body>
            </Card.Body>
            <Card.Footer justifyContent="flex-end" gap="2">
            </Card.Footer>
        </Card>
    )
}
```
シリアライズの問題が発生します。このパターンはReact Server Components（RSC）と互換性はないのです。エラーが発生するでしょう。
https://github.com/facebook/react/blob/473522093d3dd95582729d01cd5c0d15dcc9cd3b/packages/react-server-dom-webpack/src/ReactFlightWebpackReferences.js#L188-L192

以下のissueで議論されています。
- ["Dot notation client component breaks consuming RSC"](https://github.com/vercel/next.js/issues/51593)
- ["This is probably a bug in the React Server Components bundler"](https://github.com/vercel/next.js/issues/58776)

Server Componentsの場合、`Card.Root` は `Card` のプロパティとしてアクセスされます。しかし、`Card` は関数であり、JSONにシリアライズできません。このためエラーが発生します。
コンポーネント要素を持っている場合、`type`フィールドはコンポーネント関数を参照します。

すべてを正しくJSONに変換するために、Reactは独自の`replacer`関数を`JSON.stringify()`に渡して、コンポーネント関数の参照します。

具体的には、React要素がシリアライズされる際に以下が行われます。
1. 基本的なHTMLタグ（typeフィールドが「``div``」のような文字列）であれば、処理は不要です。
2. Server Component（typeフィールドに格納されている）をpropsで呼び出し、シリアライズします。Server Componentがレンダーされ、Server Componentを基本的なHTMLタグに変換することが目的です。
3. Client Componentのときは、処理せずともシリアライズできます。typeフィールドは実際にはモジュール参照オブジェクトを指しており、コンポーネント関数ではないためです。

https://github.com/facebook/react/blob/473522093d3dd95582729d01cd5c0d15dcc9cd3b/packages/react-server/src/ReactFlightServerTemporaryReferences.js#L71-L76

This example can still have similar tree-shaking issues as the first one.
Tree shaking works best when the code is structured in a way that allows the optimiser to statically analyse which parts of the code are unused. When we use Object.assign, we're dynamically attaching properties (Header, Body, and Footer) to the Card function. This makes it harder for many tree-shaking algorithms to determine that Header and Footer are unused because:
- Dynamic Property Assignment: Object.assign dynamically assigns properties to Card. Most tree-shaking tools rely on static analysis, and they might not "see through" the dynamic nature of this assignment.
- Module Boundaries: Tree shaking works more effectively when each function or component is imported separately. By bundling these components together using Object.assign, you're reducing the optimiser's ability to detect unused parts.

```jsx
export default Object.assign(Card, {
  Header,
  Footer,
});
```
https://github.com/react-bootstrap/react-bootstrap/blob/5cfa9895b52a68a6596cdea8822fffe985c0df66/src/Card.tsx#L105


```jsx
// card.tsx
export function CardRoot() {}
export function CardHeader() {}
export function CardFooter() {}

// namespace.ts 
export {
  CardBody as Body,
  CardRoot as Root,
  CardFooter as Footer,
  CardHeader as Header,
} from "./card";

// index.tsx
export * as Card from "./namespace";
```
https://github.com/chakra-ui/chakra-ui/tree/main/packages/react/src/components/card


```jsx
// index.tsx
export * as Card from "./namespace";
```
code-smell として、`export * as Card from "./namespace";` は避けるべきとされています。

Avoid re-export all.
> Deeply nested import chains in modular projects, where a barrel file imports another barrel file, can lead to increased load times and complexity. [省略]

### 参考
1. https://biomejs.dev/linter/rules/no-re-export-all/
2. https://github.com/thepassle/eslint-plugin-barrel-files/blob/main/docs/rules/avoid-re-export-all.md
3. https://e18e.dev/guide/speedup.html

https://rollupjs.org/repl/?version=4.21.1&shareable=JTdCJTIyZXhhbXBsZSUyMiUzQW51bGwlMkMlMjJtb2R1bGVzJTIyJTNBJTVCJTdCJTIyY29kZSUyMiUzQSUyMiUyRiUyRiUyMFRSRUUtU0hBS0lORyU1Q25pbXBvcnQlMjAqJTIwYXMlMjBDYXJkJTIwZnJvbSUyMCcuJTJGZm5zLmpzJyUzQiU1Q24lNUNuY29uc29sZS5sb2coQ2FyZC5CYXIpJTNCJTIyJTJDJTIyaXNFbnRyeSUyMiUzQXRydWUlMkMlMjJuYW1lJTIyJTNBJTIybWFpbi5qcyUyMiU3RCUyQyU3QiUyMmNvZGUlMjIlM0ElMjJleHBvcnQlMjBjb25zdCUyMEZvbyUyMCUzRCUyMCgpJTIwJTNEJTNFJTIwNDIlNUNuZXhwb3J0JTIwY29uc3QlMjBCYXIlMjAlM0QlMjAoKSUyMCUzRCUzRSUyMDk5JTIyJTJDJTIyaXNFbnRyeSUyMiUzQWZhbHNlJTJDJTIybmFtZSUyMiUzQSUyMmZucy5qcyUyMiU3RCU1RCUyQyUyMm9wdGlvbnMlMjIlM0ElN0IlMjJvdXRwdXQlMjIlM0ElN0IlMjJmb3JtYXQlMjIlM0ElMjJlcyUyMiU3RCUyQyUyMnRyZWVzaGFrZSUyMiUzQXRydWUlN0QlN0Q=
