---
title: "<Card.Root> „ÅÆ„Çà„ÅÜ„Å´ÂÆüË£Ö„Åô„Åπ„Åç„Å™„ÅÆ„Åã"
emoji: "üìë"
type: "tech" # tech: ÊäÄË°ìË®ò‰∫ã / idea: „Ç¢„Ç§„Éá„Ç¢
topics: []
published: false
---
## „ÅØ„Åò„ÇÅ„Å´
`<Card.Root>` „ÅÆ„Çà„ÅÜ„Å™Ë®òËø∞„ÇíË¶ã„Åã„Åë„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅdot notation „Å®Âëº„Å∞„Çå„ÇãË®òÊ≥ï„Åß„Åô„ÄÇ
dot notation„ÄÄ„Å´Èñ¢„Åô„Çã issue „ÇíË¶ã„Åã„Åë„Åü„ÅÆ„Åß„ÄÅ‰Ωï„ÅåËµ∑„Åç„Å¶„ÅÑ„Çã„ÅÆ„Åã„ÇíË™ø„Åπ„Å¶„Åø„Åæ„Åó„Åü„ÄÇ

## dot notation „ÅßÂÆüË£Ö„Çí„Åô„Çã„Å®‰Ωï„ÅåËµ∑„Åì„Çã„ÅÆ„Åã
One approach is using namespaced components, also known as dot notation, where related parts are grouped together. 
Recently, a significant issue with React Server Components (RSC) has been raised, especially in the discussions 
- "Dot notation client component breaks consuming RSC"
- "Issue #58776: Challenges with Namespaced Components in RSC‚Äù

```jsx
function Card() {}

Card.Header = function Header() {}
Card.Body = function Body() {}
Card.Footer = function Footer() {}

export default Card;
```

This example can still have similar tree-shaking issues as the first one.
Tree shaking works best when the code is structured in a way that allows the optimiser to statically analyse which parts of the code are unused. When we use Object.assign, we're dynamically attaching properties (Header, Body, and Footer) to the Card function. This makes it harder for many tree-shaking algorithms to determine that Header and Footer are unused because:
- Dynamic Property Assignment: Object.assign dynamically assigns properties to Card. Most tree-shaking tools rely on static analysis, and they might not "see through" the dynamic nature of this assignment.
- Module Boundaries: Tree shaking works more effectively when each function or component is imported separately. By bundling these components together using Object.assign, you're reducing the optimiser's ability to detect unused parts.

```jsx
export default Object.assign(Card, {
  Header,
  Footer,
});
```
https://github.com/react-bootstrap/react-bootstrap/blob/5cfa9895b52a68a6596cdea8822fffe985c0df66/src/Card.tsx#L105


```jsx
// card.tsx
export function CardRoot() {}
export function CardHeader() {}
export function CardFooter() {}

// namespace.ts 
export {
  CardBody as Body,
  CardRoot as Root,
  CardFooter as Footer,
  CardHeader as Header,
} from "./card";

// index.tsx
export * as Card from "./namespace";
```
https://github.com/chakra-ui/chakra-ui/tree/main/packages/react/src/components/card


```jsx
// index.tsx
export * as Card from "./namespace";
```
code-smell „Å®„Åó„Å¶„ÄÅ`export * as Card from "./namespace";` „ÅØÈÅø„Åë„Çã„Åπ„Åç„Å®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ

Avoid re-export all.
> Deeply nested import chains in modular projects, where a barrel file imports another barrel file, can lead to increased load times and complexity. [ÁúÅÁï•]

### ÂèÇËÄÉ
1. https://biomejs.dev/linter/rules/no-re-export-all/
2. https://github.com/thepassle/eslint-plugin-barrel-files/blob/main/docs/rules/avoid-re-export-all.md
3. https://e18e.dev/guide/speedup.html

https://rollupjs.org/repl/?version=4.21.1&shareable=JTdCJTIyZXhhbXBsZSUyMiUzQW51bGwlMkMlMjJtb2R1bGVzJTIyJTNBJTVCJTdCJTIyY29kZSUyMiUzQSUyMiUyRiUyRiUyMFRSRUUtU0hBS0lORyU1Q25pbXBvcnQlMjAqJTIwYXMlMjBDYXJkJTIwZnJvbSUyMCcuJTJGZm5zLmpzJyUzQiU1Q24lNUNuY29uc29sZS5sb2coQ2FyZC5CYXIpJTNCJTIyJTJDJTIyaXNFbnRyeSUyMiUzQXRydWUlMkMlMjJuYW1lJTIyJTNBJTIybWFpbi5qcyUyMiU3RCUyQyU3QiUyMmNvZGUlMjIlM0ElMjJleHBvcnQlMjBjb25zdCUyMEZvbyUyMCUzRCUyMCgpJTIwJTNEJTNFJTIwNDIlNUNuZXhwb3J0JTIwY29uc3QlMjBCYXIlMjAlM0QlMjAoKSUyMCUzRCUzRSUyMDk5JTIyJTJDJTIyaXNFbnRyeSUyMiUzQWZhbHNlJTJDJTIybmFtZSUyMiUzQSUyMmZucy5qcyUyMiU3RCU1RCUyQyUyMm9wdGlvbnMlMjIlM0ElN0IlMjJvdXRwdXQlMjIlM0ElN0IlMjJmb3JtYXQlMjIlM0ElMjJlcyUyMiU3RCUyQyUyMnRyZWVzaGFrZSUyMiUzQXRydWUlN0QlN0Q=
