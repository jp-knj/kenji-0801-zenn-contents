---
title: "Web Components の全体像"
---
## はじめに
Web Components は、Web の標準であり、Web の未来を築くための技術です。

Webコンポーネントの scope と　encapsulation は 一般的なプログラミングを学ぶ際に学んだかもしれないすべての伝統的な理由（情報隠蔽、メンテナンス、コードベースのスケーラビリティなど）にとって重要です。
しかし、Webコンポーネントに関しては、HTMLとCSSのランタイムに追加のメタデータを提供し、ペイントとレイアウトを最適化することもできます。


## Shadow DOM
DOM と関連するスタイルをスコープ、カプセル化、および構成するためのHTMLの基本的なメカニズムです。
これは多面的な機能であり、さまざまな機能が継続的に拡張されています。

https://web.dev/articles/shadowdom-v1

https://medium.com/javascript-in-plain-english/understanding-the-shadow-dom-8495860b39bf

## 名前付きスロット割り当て（完全サポート）
オリジナルのv1シャドウDOM仕様は、シャドウDOM内の名前付き<slot>要素を使用して要素の構成プレースホルダーを定義する完全に宣言的なメカニズムを提供しました。
コンポーネントの消費者は、ホスト要素の任意の子要素にスロット属性を配置するだけで、ブラウザがその要素のレンダリングされた出力を自動的にスロットの位置に「投影」します。

## オープンモードとクローズドモード（完全サポート）
attachShadow() APIのmodeオプションは、v1シャドウDOM仕様の一部でした。これにより、コンポーネントの作成者は、好みのカプセル化モードを選択できます。
オープンモードでは、shadowRootにホストの外部からアクセスできるのに対し、クローズドモードではアクセスを拒否します。

https://medium.com/revillweb/open-vs-closed-shadow-dom-9f3d7427d1af

## イベントの再ターゲティング（完全サポート）
シャドウDOM内の要素からイベントが発火すると、それらのイベントは「再ターゲティング」され、シャドウDOMホストから発生したように見えるようになります。この機能は、内部構造を適切にカプセル化するために重要な部分です。

## 手動スロット割り当て（完全サポート） 
スロット要素の新しいassign APIは、宣言的のみのスロット割り当てメカニズムに加えて、命令的APIを提供することで、v1の元のスロット割り当て機能を拡張します。

## フォーカス委譲（完全サポート） 
このv1以降の機能により、シャドウDOMのホスト要素にフォーカスがある場合、ブラウザにシャドウDOM内の特定の要素に代わってフォーカスを委譲するよう指示できます。デフォルトでは最初のフォーカス可能な要素が選択されますが、autofocus属性を使用してこれを上書きできます。

## クロスルートARIA（ほぼコンセンサス）
コミュニティとブラウザベンダーとのほぼ合意に達した今後の機能であるクロスルートARIAは、シャドウDOMの外部のARIAクリティカル要素をシャドウDOM内の要素と関連付けることを大幅に簡素化します。たとえば、シャドウDOMの外部のlabel要素をシャドウDOM内のinput要素に関連付けることができます。このようなARIAシナリオには今日でも解決策がありますが、心臓の弱い人には向いていません。クロスルートARIAはこれを大幅に改善します。

## Shadow CSSプロパティ定義（コンセンサス） 
今日、一部のブラウザは@property構文をCSSで使用してCSSカスタムプロパティを定義することを可能にしています。しかし、これはまだシャドウDOMでは機能しません。カスタム要素コードからCSSオブジェクトモデルを常に使用してこれらをグローバルに定義することはできますが、シャドウDOM内から宣言的な形式でこれを利用できるようにすることは常識的な改善です。これはコンセンサスに達しているので、新しいCSS構文をブラウザが一般的にサポートするにつれて、間もなくこれを見ることを期待しています。

https://medium.com/@mariusbongarts/the-complete-web-component-guide-shadow-dom-2e40921eb77

## Custom Elements

スコープ付きエレメントレジストリ（コンセンサス）

カスタムエレメントのv1仕様では、すべてのエレメントは、グローバルなカスタムエレメントレジストリにcustomElementsグローバルを介して登録されていました。この新しい追加により、非グローバルなレジストリをインスタンス化し、それらにカスタムエレメントを登録する機能が可能になります。

```javascript
const myRegistry = new CustomElementRegistry();
myRegistry.define("my-element", MyElement);
```

レジストリ内のエレメントは、レジストリが割り当てられたシャドウDOMにのみ定義されます。これにより、ブラウザ内のスコーピングが大幅に改善され、エレメント定義を必要に応じてシャドウルートごとにスコープできるようになります。これは、ブラウザに出荷されるときに大きな影響を与え、新しいアーキテクチャの可能性を開きます。現在、コミュニティとベンダー間でコンセンサスが得られており、Chromiumが最初の実装に取り組んでいます。


## レンダリングとパフォーマンス

レンダリングとパフォーマンスは、Webコンポーネントにとって重要です。基本は今日確立されていますが、これは探求、議論、および将来の革新の活発な分野のままです。

HTMLテンプレート要素（完全サポート）

HTMLTemplateElementとその非アクティブなHTMLコンテンツを定義する能力は、v1 Webコンポーネント機能の重要な部分でした。この要素がなければ、ブラウザによってアクティブ化されないHTMLを宣言する方法はありませんでした。これにより、同じHTMLを要求に応じて繰り返しレンダリングする必要があるコンポーネントを作成することが困難になりました。

### 宣言型シャドウDOM（ほとんどサポート）

シャドウDOMのv1仕様は、attachShadow() JavaScript APIを介してのみシャドウルートの作成を可能にしました。この新しいシャドウDOMの拡張により、JavaScriptを使用せずにHTMLでシャドウDOMコンテンツを完全に宣言できるようになり、サーバーフレームワークに興味深い新しい可能性が開かれます。

html
Copy code
<host-element>
<template shadowrootmode="open">
<slot></slot>
</template>
<h2>Light content</h2>>
</host-element>
この仕様はtemplate要素を再利用します。それに惑わされてはいけません。これはテンプレートではなく、HTMLパーサーによってシャドウルートにストリーミングされるアクティブなDOMです。

Firefoxを除くすべてのブラウザは現在、宣言型シャドウDOMをサポートしています。必要に応じて、この機能は数行のJavaScriptコードでポリフィルできます。

### 子要素変更コールバック（提案）

Webコンポーネントには、カスタムエレメントのv1仕様で示されているように、定義されたライフサイクルがありますが、それは将来ライフサイクルを拡張できないという意味ではありません。一般的な開発者の課題の1つは、Webコンポーネントが子ノードの追加または削除に応答できるようにすることです。これは、slotchangeイベントとMutationObserverを使用して今日実現できますが、パフォーマンスの向上、簡素化、およびHTMLパーサー自体との統合を提供できるライフサイクルコールバック（例：childrenChangedCallback()）があると便利です。現在、ストローマン提案があり、実装者からの関心があるようです。これを次の段階に進めるには、完全な提案が必要です。

### テンプレートインスタンス化

HTMLにはテンプレートがありますが、データに接続されたテンプレートをインスタンス化し、依存するデータが変更されたときにそれらを更新するメカニズムはまだありません。この「テンプレートインスタンス化」の領域には、それぞれが独立して価値のあるいくつかの部分があります。

DOMパーツ（提案） - この提案は、DOMツリー内の特定の場所でコンテンツを挿入または置換するための標準メカニズムを提供します。これは、より効率的なテンプレートエンジンの作成や、既存のWebコンポーネントライブラリおよびJavaScriptフレームワークでのバッチ更新を支援するための低レベルのエンブラーとして考えることができます。これは、リアクティビティやテンプレート構文の解決策を提供するものではありませんが、DOMの部分を特定および更新するための低レベルの標準インフラストラクチャを提供するだけです。
テンプレート構文（識別） - ターゲティングとバッチ更新のための低レベルインフラストラクチャが確立され、既存のライブラリによって成功裏に使用されると、構文に関する大きな議論が行われることができます。テンプレート構文は非常に論争の的ですが、HTMLにはこれのための基本的な言語があるべきだと認識されています。たとえそれが他のライブラリのコンパイルターゲットとしてのみ機能する場合であってもです。
リアクティビティ（識別） - DOMパーツは、DOMのバッチ更新のための標準メカニズムを提供します。テンプレート構文は、DOMパーツを作成するための宣言的なメカニズムを提供します。残っているのは、DOMパーツの更新を実行するタイミングを決定するメカニズムです。ここでリアクティビティが全体像を完成させるために登場します。これもまた論争の的ですが、WebコンポーネントのattributeChangedCallback()を介してすでにいくつかの前例があります。このトピックについては、さらに多くの探求が必要です。
テンプレートインスタンス化の作業カテゴリーは、上記の3つのサブ機能に分けられています。これにより、論争の少ない問題を早期に解決できるようになり、既存のライブラリとフレームワークが、より少ない摩擦でコミュニティにとってパフォーマンスを向上させる能力を活用できる道筋が提供されます。

